<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信小程序通过api接口将json数据展现到小程序示例]]></title>
    <url>%2F2017%2F07%2F10%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%9A%E8%BF%87api%E6%8E%A5%E5%8F%A3%E5%B0%86json%E6%95%B0%E6%8D%AE%E5%B1%95%E7%8E%B0%E5%88%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[用到的知识 wx.request 请求接口资源(微信小程序api的发起请求部分) swiper实现轮播图的组件 wx:for 循环语句 微信小程序的基础知识 实现原理首先看一下这个请求函数12345678910111213141516171819202122wx.request(&#123; //请求地址 url:"https://locally.uieee.com/xxx", //请求的参数 data：&#123;&#125;, //设置请求的header header:&#123;&#125;, //请求方式 method:"GET", //数据类型 dataType:'json', //成功请求执行的回调函数 success:function(res)&#123; console.log(res); &#125;, //请求失败执行的回调函数 fail:function(res)&#123; console.log(res); &#125;, //接口调用结束的回调函数 (调用成功、失败都会执行) complete:function(res)&#123;&#125;,&#125;) 1.接口数据接口数据的json格式的开头12345"state":"0","stories":[&#123;id: 1, image: "http://ww1.sinaimg.cn/mw690/006ThXL5ly1fj7zx3w751j30u00dmgy3.jpg"&#125;,&#123;id: 2, image: "http://ww1.sinaimg.cn/mw690/006ThXL5ly1fj6ckx9tlwj30u00fqk8n.jpg"&#125;] 2. index.js在index.js里获取数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// pages/profile/profile.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; duration: 2000, indicatorDots: true, autoplay: true, interval: 3000, loading: false, plain: false, sliderList:[] &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; var _this = this; //不要漏了这句，很重要滴！！！ wx.request(&#123; url:"https://locally.uieee.com/xxx", headers: &#123; 'Content-Type': 'application/json' &#125;, success:function(res)&#123; /** * this.setData 有两个功能： * 1. 更新数据 * 2. 更新视图 */ //将获取到的json数据，存在名字叫sliderList的这个数组中 _this.setData(&#123; sliderList:res.data &#125;) &#125; &#125;) &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123;&#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123;&#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123;&#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123;&#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123;&#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123;&#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123;&#125;&#125;) index.wxml在index.wxml中渲染1234567&lt;view class='slider'&gt; &lt;swiper indicator-dots="&#123;&#123;indicatorDots&#125;&#125;"autoplay="&#123;&#123;autoplay&#125;&#125;" class="banners" interval="&#123;&#123;interval&#125;&#125;" duration="&#123;&#123;duration&#125;&#125;"&gt; &lt;swiper-item wx:for="&#123;&#123; sliderList &#125;&#125;" wx:key="id" &gt; &lt;image src="&#123;&#123; item.image &#125;&#125;" width="375" height="150" mode="aspectFill" lazy-load /&gt; &lt;/swiper-item&gt; &lt;/swiper&gt;&lt;/view&gt;]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局学习和总结]]></title>
    <url>%2F2017%2F06%2F11%2Fflex-conclusion%2F</url>
    <content type="text"><![CDATA[前言很长一段时间, 我知道有flex这个布局方式, 但是始终没有去学它. 最近由于学习小程序，发现里面需要使用flex布局, 于是决定学习一下. 在拜读了阮一峰的flex布局教程和HaoyCn有关flex属性的回答后整理成此文章，以便加深印象。 什么是flexFlexbox Layout，官方名为 CSS Flexible Box Layout Module, 意为”弹性布局”，是CSS3中引入的一种更加灵活高效的布局/对齐/排序方式(还有一种更适合大型布局的网格布局CSS Grid Layout Module). flex是flexible的缩写. 任何一个容器都可以指定为flex布局。 123.box &#123; display: flex;&#125; 行内元素也可以使用flex布局。 123.box &#123; display: inline-flex;&#125; flex的基本概念 1、采用flex布局的元素被称为flex容器（flex container），他的子元素即为flex元素（flex item）。2、flex容器中包含两个相互垂直的轴，即主轴（main axis）和副轴（cross axis)。3、flex元素沿主轴从主轴起点 (main start)到主轴终点 (main end)依次排布。4、如果flex容器包含多行flex元素，则flex行（flex lines）沿副轴从副轴起点（cross start）到副轴终点（cross end)依次排布。5、单个flex元素占据的主轴空间叫做主轴程度（main size），占据的副轴空间叫做副轴长度（cross size）。 flex的兼容性 flex属性用于flex容器的属性以下6个属性设置在容器上 属性 含义 flex-direction 主轴方向 flex-wrap 换行样式 flex-flow 前两个的简写形式 justify-content 主轴对齐方式 align-items 单行的副轴对齐方式 align-content 多行的副轴对齐方式 注意：flex容器的column-*属性会失效。flex容器无法拥有::first-line和 ::first-letter虚元素。 flex-direction属性flex-direction 属性决定主轴方向(即项目的排序方向)。 含义 主轴方向 可选值 row 、row-reverse 、 column 、 column-reverse 默认值 row row 主轴为水平方向，七点在左端。 row-reverse 主轴为水平方向，起点在右端。 column 主轴为垂直方向，起点在上沿。 column-reverse 主轴为垂直方向，起点在下沿。 123.box&#123; flex-direction: row | row-reverse | column | column-reverse;&#125; flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 flex-flow属性flex-flow属相是flex-direction属性和flex-wrap属性的简写形式，默认值为 row nowrap。123.box&#123; flex-flow:&lt;flex-direction&gt;||&lt;flex-wrap&gt;;&#125; justify-content属性它可能取5个值，具体对齐方式与轴的方向有关，下面假设主轴为从左到右。 值 主轴方向 flex-start 默认值：左对齐 flex-end 右对齐 center 居中 space-between 两端对齐，项目之间的间隔都相等。 space-around 每个项目两侧的间隔相等。所以，项目之间比项目与边框的间隔大一倍。 123.box&#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; align-items属性align-items属性定义项目在交叉轴上如何对齐。它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 值 主轴方向 flex-start 交叉轴的起点对齐。 flex-end 交叉轴的终点对齐。 center 交叉轴的中点对齐。 baseline 项目的第一行文字的基线对齐。 stretch （默认值）:如果项目未设置高度或设为auto，将占满整个容器的高度。 123.box&#123; align-items: flex-start | flex-end | center | baseline | stretch; &#125; align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。该属性可能取6个值。 值 主轴方向 flex-start 与交叉轴的起点对齐。 flex-end 与交叉轴的终点对齐。 center 与交叉轴的中点对齐。 space-between 与交叉轴两端对齐。轴线之间的间隔平均分布。 space-around 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch （默认值）：轴线占满整个交叉轴。 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 用于flex元素的属性这类属性有6种，分别为: 属性 含义 order 排列顺序。 align-self flex元素的副轴对齐方式，对应与flex容器的align-items。 flex-grow 放大比例。 flex-shrink 缩小比例。 flex-basis 初始大小。 flex （上面三个的简写形式。） 注意：flex元素的 float，clear和vertical-align会失效。 order属性order属性定义项目的排序顺序。数值越小，排列越靠前，默认为0. 123.box&#123; order:&lt;integer&gt;;&#125; align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.box&#123; align-self:&#123; auto | flex-start | flex-end | center | baseline | stretch &#125;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 123.box&#123; flex-grow:&lt;number&gt;; /*default 0*/&#125; flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，盖项目将缩小。flex-shrink为 0 则表示，即使flex容器空间不足，该flex元素也不缩小。 123.box&#123; flex-shrink:&lt;number&gt;; /* default 1 */&#125; flex-basis属性 含义 初始大小 可选值 auto、(非负值)。 默认值 auto。 123.box &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; flex-basis定义了分配剩余空间之前flex元素的初始大小，可为长度值（如 20%，5rem等）或 auto等关键词。flex-basis: auto表示, 以flex元素的主轴长度为flex-basis. 若flex元素的主轴长度也是auto, 则以flex元素内容(即所有子元素)的大小为flex-basis。 flex属性 含义 flex-grow, flex-shrink和flex-basis的简写形式 可选值 none [ &lt;‘flex-grow’&gt; &lt;‘flex-shrink’&gt;?、&lt;‘flex-basis’&gt; ] 默认值 0 1 auto ||用来分割两个或多个选项, 从中选取一个或多个, 不限次序. |用来分割两个或多个选项, 从中选取一个. []只是用来分组的. ?代表可选. 举例来说, a | [ b || c ]包含的可能情况有a, b, c, b c, c b.现在回过头来再看none | [ &lt;‘flex-grow’&gt; &lt;‘flex-shrink’&gt;? || &lt;‘flex-basis’&gt; ]就清晰多了.注意, none是一个特殊值, 相当于0 0 auto.另外, 如果flex中不指定: flex-grow成员, 则flex-grow会被置为1. flex-shrink成员, 则flex-shrink会被置为1. flex-basis成员, 则flex-basis会被置为0.注意: flex的初始值是0 1 auto, 即由每个flex因子本身的默认值组成(比方说flex-grow的默认值就是0).]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>Flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【读书】《锋利的jQuery》]]></title>
    <url>%2F2017%2F03%2F10%2Fsharp-jquery%2F</url>
    <content type="text"><![CDATA[通过对《锋利的jQuery》（第二版）一书的学习，发现此书讲解通俗易懂，是学习jQuery的一本很好的指导书，特作如下总结。此书主要讲解了jQuery的常用操作，包括认识jQuery，jQuery选择器，jQuery中的DOM操作，jQuery中的事件和动画，jQuery对表单、表格的操作及更多应用，jQuery与Ajax的应用等。 jQuery的优势jQuery强调的理念是写得少，做的多。jQuery独特的选择器、链式操作、事件处理机制和封装完善的Ajax都是其他JavaScript库望尘莫及的。概括起来，jQuery有以下优势。 轻量级 强大的选择器 出色的DOM操作 可靠的事件处理机制 完善的Ajax 不污染顶级变量 出色的浏览器兼容性，支持IE6.0+、Firefox3.6+、Safari5.0+、Opera、Chrome 链式操作方式 隐式迭代 行为层与结构层的分离 丰富的插件支持 完善的文档 开源 jQuery代码的编写在jQuery库中，$就是jQuery的一个简写形式，例如$(&quot;#foo&quot;)和jQuery(&quot;#foo&quot;)是等价的。规范：1、对于同一个对象不超过3个操作的，可以直接写在一行2、对于同一个对象的较多操作，建议每行写一个操作3、对于多个对象的少量操作，可以每个对象写一行，涉及子元素的，可以考虑缩进建议：jQuery对象使用$开头，例：var $variable = jQuery对象，var variable= DOM对象 window.onload 和 $(document).ready() 对比 - window.onload $(document).ready() 执行时间 必须等待网页中所有的内容加载完毕（）包括图片才执行 只需要 DOM 加载完就执行（不包括图片等） 编写个数 不能同时编写多个 能同时编写多个 简化写法 无 $(document).ready(function(){}) 可以简写成 $(function(){}) jQuery 的链式操作风格用过jQuery的朋友都知道他强大的链式操作，方便，简洁，易于理解， 如下:1$(this).addClass("current").next().show().parent().siblings().children("a").removeClass("current").next().hide(); 为了进一步改善代码的可读性和可维护性可将代码改为如下格式：1234$(this).addClass("current") // 给当前元素添加 "current" 样式 .next().show() // 下一个元素显示 .parent().siblings().children("a").removeClass("current") // 父元素的同辈元素的子元素 &lt;a&gt; 移除 "current" 样式.next().hide(); //他们的下一个元素隐藏 jQuery 对象和 DOM 对象DOM对象就是DOM树中的节点。可以通过JavaScript中的getElementsByTagName或者getElementById来获取元素节点。 jQuery对象就是通过jQuery包装DOM对象后产生的对象。 在jQuery对象中违法使用DOM对象的任何方法。同样，DOM对象也不能使用jQuery里的方法。 所以我们要区分什么是JavaScript原生方法，什么是jQuery方法。 以下是都是错误的方法：123$("#id").innerHTML;$("#id").checked;document.getElementById("id").html(); jQuery对象和DOM对象的相互转换在讨论jQuery对象和DOM对象的相互转换之前，先约定好定义变量的风格，如果获取的对象时jQuery对象，那么在变量前面加上$符号。 jQuery 对象转化为 DOM 对象jQuery对象不能使用DOM中的方法，jQuery提供了两种方法将一个jQuery对象转换DOM对象，即[index]和get（index）。 （1）jQuery对象是一个类似数组的对象，可以通过[index]得到相应DOM对象。 123var $cr = $("#cr"); //jQuery对象var cr = $cr[0]; //将jQuery对象转为DOM对象console.log(cr); //查看是否转换成功 （2）通过get(index)得到。123var $cr = $("#cr"); //jQuery对象var cr = $cr.get(0); //DOM对象console.log(cr); //查看是否转换成功 DOM 对象转化为 jQuery 对象只需要使用$()将DOM对象包装起来即可得到jQuery对象。 12var cr = document.getElementById("cr"); //DOM对象var $cr = $(cr); //将DOM对象转换jQuery对象 注：DOM对象只能使用DOM方法，jQuery对象只能使用jQuery的方法。 解决 jQuery 和其他库的冲突在 jQuery 库中，几乎所有的插件都被限制在它的命名空间里。通常，全局对象都被很好地储存在 jQuery 的命名空间里。因此和其他库一起使用时，不会引起冲突。注：默认情况下，jQuery用$作为自身的快捷方式。 1、jQuery库在其他库之后导入 （1）在其他库和jQuery库加载完毕之后，可以在任何时候调用jQuery.noConflict()函数将变量$的控制权移交其他的JavaScript库。例：12345678910111213&lt;!-- 引入prototype库 --&gt;&lt;script type="text/javascript" src="lib/prototype.js"&gt;&lt;/script&gt;&lt;!-- 引入jQuery库 --&gt;&lt;script type="text/javascript" src="lib/jQuery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; jQuery.noConflict(); //将变量$的控制权移交给prototype.js jQuery(function()&#123; //使用jQuery jQuery("p").click(function()&#123; alert(jQuery(this).text()); &#125;); &#125;); $('pp').style.display = 'none'; //使用prototype.js隐藏元素&lt;/script&gt; （2）想确保jQuery不与其他库冲突，又想自定义快捷方式：例：123456789&lt;script type="text/javascript"&gt; var $j = jQuery.noConflict(); //自定义快捷方式 $j(function()&#123; //使用jQuery，利用自定义快捷方式 $j $j("p").click(function()&#123; alert.($j(this).text()); &#125;); &#125;); $('pp').style.display = 'none'; //使用prototype.js隐藏元素&lt;/script&gt; （3）如果你还想继续使用 $ 而不管其他函数的 $() 方法，同时又不想与其他库冲突，那么你可以其一、123456789&lt;script type="text/javascript"&gt; jQuery.noConflict(); //将变量$的控制权移交给prototype.js jQuery(function($)&#123; //使用jQuery设定页面加载时执行的函数 $("p").click(function()&#123; //函数内部继续使用$() alert.($(this).text()); &#125;); &#125;); $('pp').style.display = 'none'; //使用prototype.js隐藏元素&lt;/script&gt; 其二、1234567891011&lt;script type="text/javascript"&gt; jQuery.noConflict(); //将变量$的控制权移交给prototype.js (function($)&#123; //定义匿名函数 $(function()&#123; //匿名函数内部的$均为jQuery $("p").click(function()&#123; alert.($(this).text()); &#125;); &#125;); &#125;)(jQuery); //执行匿名函数且传递实参jQuery $('pp').style.display = 'none'; //使用prototype.js隐藏元素&lt;/script&gt; 2、jQuery在其他库之前导入 直接使用jQuery而非$来做jQuery的工作，$()方法作为其他库的快捷方式，无需调用jQuery.noConflict()方法 jQuery选择器jQuery选择器的优势1、简洁的写法使用$(&quot;#ID&quot;)代替document.getElementById()，使用$(&quot;tagName&quot;)代替document.getElementsByTagName()函数2、支持CSS1到CSS3选择器3、完善的处理机制，即，使用jQuery获取不存在的元素也不会报错 注：$(&quot;#tt&quot;)获取的永远是对象，即使网页上没有元素，因此当要使用jQuery检查某个元素在网页上是否存在，不能使用如下代码：12345if($("#tt"))&#123; /* do something */ &#125;应根据获取的元素长度来判断：if($("#tt").length &gt; 0)&#123; /* do something */ &#125;或转换成DOM对象：if($("#tt")[0])&#123; /* do something */ &#125; 基本选择器 选择器 描述 返回 示例 #id 根据给定id匹配一个元素 单个元素 $(“#test”)选取id为test的元素 .class 根据给定类名匹配元素 集合元素 $(“.test”)选取所有class为test的元素 element 根据给定元素名匹配元素 集合元素 $(“p”) * 匹配所有元素 集合元素 $(“*”) selector1,selector2… 将每个选择器匹配到的元素合并后一起返回 集合元素 $(“div,span,p.myClass”) 层次选择器 选择器 描述 返回 示例 $(“ancestor descendant”) 选取ancestor元素里所有descendant（后代）元素 集合元素 $(“div span”)选取div里所有span元素 $(“parent&gt;child”) 与CSS的子选择器一样 集合元素 $(“div&gt;span”) $(“prev+next”) 与CSS的相邻同胞选择器一样 集合元素 $(“.one+div”) $(“prev~sibling”) 与CSS的通用的同胞组合选择器一样 集合元素 $(“#two~div”) 可以使用next()方法代替$(&#39;prev+next&#39;)1$(".one+div"); ==&gt; $(".one").next("div"); 使用nextAll()代替$(&#39;#prev~sibling&quot;)1$("#prev~div"); ==&gt; $("#prev").nextAll("div"); 基本过滤选择器 选择器 描述 返回 示例 :first 选取第一个元素 单个元素 $(“div:first”)选取所有元素中第1个元素 :last 选取最后一个元素 单个元素 $(“div:last”)解释类似:first :not(selector) 去除所有与给定选择器匹配的元素 集合元素 $(“input:not(.myClass)”) :even 选取索引是偶数的元素，索引从0开始 集合元素 $(“input:even”) :odd 选取索引是奇数的元素，索引从0开始 集合元素 $(“input:odd”) :eq(index) 选取索引是index的元素，index从0开始 单个元素 $(“input:eq(1)”) :gt(index) 选取索引大于index的元素，index从0开始 集合元素 $(“input:gt(1)”) :lt(index) r选取索引小于index的元素，index从0开始 集合元素 $(“input:lt(1)”) :header 选取所有标题元素，例h1，h2 集合元素 $(“:header”) :animated 选取正在执行动画的元素 集合元素 $(“div:animated”) :focus 选取获得焦点的元素 集合元素 $(“:focus”) 内容过滤选择器 选择器 描述 返回 示例 :contains(text) 选取含有文本内容为“text”的元素 集合元素 $(“div:contains(‘me’)”)选取所有含有文本”me”的div元素 :empty 选取不包含子元素或文本的空元素 集合元素 $(“div:empty”) :has(selector) 选取含有选择器所匹配的元素的元素 集合元素 $(“div:has(p)”)选取含有p元素的div元素 :parent 选取含有子元素或文本元素的元素 集合元素 $(“div:parent”) 可见性过滤选择器 选择器 描述 返回 示例 :hidden 选取所有不可见元素 集合元素 $(“:hidden”)选取所有不可见元素 :visible 选取所有可见元素 集合元素 $(“div:visible”)选取可见的div元素 属性过滤选择器 选择器 描述 返回 示例 [attribute] 选择拥有此属性的元素 集合元素 $(“div[id]”)选取拥有id属性的div元素 [attribute=value] 选择拥有属性值为value的元素 集合元素 $(“div[title=test]”) [attribute!=value] 选择属性值不等于value的元素 集合元素 $(“div[title!=test]”),没有属性title的元素也会被选取 [attribute^=value] 选择属性值以value开始的元素 集合元素 $(“div[title^=test]”) [attribute$=value] 选择属性值以value结束的元素 集合元素 $(“div[title$=test]”) [attribute*=value] 选择属性值含有value的元素 集合元素 $(“div[title*=test]”) [attribute丨=value] 选择属性等于给定字符串或以该字符串为前缀（该字符串后跟一个连字符‘-’）的元素 集合元素 $(“div[title丨=”en”]”)选取title属性等于en或以en为前缀的元素 [attribute~=value] 选取属性用空格分隔的值中包含一个给定值的元素 集合元素 $(“div[title~=”uk”]”) [attribute1][attribute2] … 用属性选择器合并成复合选择器，满足多个条件，缩小范围 集合元素 $(“div[id][title$=”test”]”)选取拥有属性id并且属性title以”test”结束的div元素 子元素过滤选择器 选择器 描述 返回 示例 :nth-child(index/even/odd/equatioin) 选取每个父元素下第index个子元素或奇偶元素，index从1开始 集合元素 将为每一个父元素匹配子元素 :first-child 选取每个父元素的第一个子元素 集合元素 将为每一个父元素匹配子元素 :last-child 选取每个父元素的最后一个子元素 集合元素 将为每一个父元素匹配子元素 :only-child 若某个元素是其父元素唯一的子元素，则被匹配 集合元素 $(“ul li:only-child”)在&lt;ul&gt;中选取是唯一子元素的&lt;li&gt;元素 :nth-child()选择器功能如下：1、:nth-child(even)选择索引是偶数的元素2、:nth-child(2)选择索引是2的元素3、:nth-child(3n+1)选择索引是（3n+1）的元素，n从1开始 表单过滤选择器 选择器 描述 返回 示例 :enabled 选取所有可用元素 集合元素 $(“#form1 :enabled”) :disabled 选取所有不可用元素 集合元素 $(“#form1 :disabled”) :checked 选取所有被选中元素，单选，复选 集合元素 $(“input:checked”) :selected 选取所有被选中选项元素，下来列表 集合元素 $(“select option:selected”) 表单选择器 选择器 描述 返回 示例 :input 选取所有&lt;input&gt;&lt;textarea&gt;&lt;select&gt;&lt;button&gt; 集合元素 $(“:input”) :text 选取所有单行文本框 集合元素 $(“:text”) :password 选取所有密码框 集合元素 $(“:password”) :radio 选取所有单选框 集合元素 $(“:radio”) :checkbox 选取所有复选框 集合元素 $(“:checkbox”) :submit 选取所有提交按钮 集合元素 $(“:submit”) :image 选取所有图像按钮 集合元素 $(“:image”) :reset 选取重置按钮 集合元素 $(“:reset”) :button 选取所有按钮 集合元素 $(“:button”) :file 选取所有上传域 集合元素 $(“:file”) :hidden 选取所有不可见元素 集合元素 $(“:hidden”) 选择器中的注意事项1、选择器中含有&quot;.&quot;，&quot;#&quot;，&quot;(&quot;，&quot;]&quot;等特殊符号，需要转义，例：$(&quot;#id\\#b&quot;)2、属性选择器中的@符号需要去掉 jQuery中的DOM操作HTML-DOM操作查找节点（1）查找元素节点，使用选择器。 获取元素节点并打印出它的文本内容：如下 123var $li = $("ul li:eq(1)"); //获取&lt;ul&gt;里第2个&lt;li&gt;节点 var li_txt = $li.text(); //获取第2个&lt;li&gt;元素节点的文本内容console.log(li_txt); //打印文本内容 （2）查找属性节点，再找到元素之后，可以使用attr()方法获取元素属性 获取属性节点并打印出它的文本内容：如下 123var $para = $("p"); //获取&lt;p&gt;节点var p_txt = $para.attr("title"); //获取&lt;p&gt;元素节点属性titleconsole.log(p_txt); 创建节点（1）创建元素节点使用工厂函数$()来完成，$(html)，根据传入的HTML标记字符串，创建一个DOM对象，并转成jQuery对象返回12345678910111213141516171819202122232425262728293031例：$("&lt;li&gt;&lt;/li&gt;")``` （2）创建文本节点，与（1）类似，将文本内容一起包含在`HTML`标记字符串中 （3）创建属性节点，与（1）类似，将节点属性一起包含在`HTML`标记字符串中 ### 插入节点方法 | 描述 | 示例---|--- |---append()| 向每个匹配的元素内部追加内容 |&lt;p&gt;我想说：&lt;/p&gt; $("p").append("&lt;b&gt;你好&lt;/b&gt;"); &lt;p&gt;我想说：&lt;b&gt;你好&lt;/b&gt;&lt;/p&gt;appendTo()|将所有匹配元素追加到指定元素中 ，与append方法颠倒$(A).append的操作，既不是将B追加到A中，而是将A追加到B中 |&lt;p&gt;我想说：&lt;/p&gt; $("&lt;b&gt;你好&lt;/b&gt;").appendTo("p"); &lt;p&gt;我想说：&lt;b&gt;你好&lt;/b&gt;&lt;/p&gt;prepend()|向每个元素内部前置内容 | &lt;p&gt;我想说：&lt;/p&gt;$("p").prepend("&lt;b&gt;你好&lt;/b&gt;");&lt;p&gt;&lt;b&gt;你好&lt;/b&gt;我想说：&lt;/p&gt;prependTo()| 将所有匹配元素前置到指定元素中，与prependTo方法颠倒 | &lt;p&gt;我想说：&lt;/p&gt;$("p").prependTo("&lt;b&gt;你好&lt;/b&gt;");&lt;p&gt;&lt;b&gt;你好&lt;/b&gt;我想说：&lt;/p&gt;after() | 在每个匹配元素之后插入内容 | &lt;p&gt;我想说：&lt;/p&gt;$("p").after("&lt;b&gt;你好&lt;/b&gt;");&lt;p&gt;我想说：&lt;/p&gt;&lt;b&gt;你好&lt;/b&gt;insertAfter() | 将所有匹配元素插入到指定元素之后 | &lt;p&gt;我想说：&lt;/p&gt;$("&lt;b&gt;你好&lt;/b&gt; ").insertAfter("p");&lt;p&gt;我想说：&lt;/p&gt;&lt;b&gt;你好&lt;/b&gt;before() | 在每个匹配的元素之前插入内容 | &lt;p&gt;我想说：&lt;/p&gt;$("p").before("&lt;b&gt;你好&lt;/b&gt;");&lt;b&gt;你好&lt;/b&gt; &lt;p&gt;我想说：&lt;/p&gt;insertBefore() | 将所有匹配元素插入到指定元素之前 | &lt;p&gt;我想说：&lt;/p&gt;$("&lt;b&gt;你好&lt;/b&gt; ").insertBefore("p");&lt;b&gt;你好&lt;/b&gt; &lt;p&gt;我想说：&lt;/p&gt;这些节点的方法不仅能将新创建的DOM元素插入到文档中，也能对原来的DOM元素进行移动。 ### 删除节点 （1）remove方法 作用从 `DOM` 中删除所有匹配的元素，传入的参数用于根据 `jQuery` 表达式来删选元素 ```javascript$("ul li:eq(1)").remove(); // 获取第二个 &lt;li&gt; 元素节点后，将它从网页中删除$li.appendTo("ul"); // 把刚才删除的元素添加到 &lt;ul&gt; 元素中 这个方法的返回值是一个指向已被删除的节点的引用，因此可以将其保存在一个变量中，以后还可以使用。 （2）datach方法 detach() 和 remove() 一样，也是从 DOM 中去掉所有匹配的元素，但是两者的区别是，这个方法不会把匹配的元素从 jQuery 对象中删除，去掉的元素的所有绑定的事件、附加的数据等都会保留下来。 （3）empty方法 并不能算是删除节点，而是清空节点，清空指定元素的所有后代节点。 复制节点使用clone方法，使用参数true可以同时复制元素所绑定事件 123456789101112131415161718192021$("ul li").click(function()&#123; $(this).clone().appendTo("ul");&#125;)``` 复制的节点后，被复制的新元素并不具有任何行为，如果需要新元素也具有相同的行为，那么就需要在 `clone()` 方法中传入参数 `true` ```javascript$("ul li").click(function()&#123; $(this).clone(true).appendTo("ul");&#125;)``` ### 替换节点 `replaceWith();`-&gt;将所有匹配的元素都替换成 `HTML` 或者 `DOM` 元素，绑定的事件将会消失 `replaceAll();`-&gt;和 `replaceWith()` 相反 ```javascript$("p").replaceWith("&lt;strong&gt;hello world&lt;/strong&gt;");$("&lt;strong&gt;hello world&lt;/strong&gt;").replaceAll("p"); 以上两句是一样的效果。注意：替换前元素有绑定事件，替换后会被清除，需要重新再新元素上重新绑定事件。 包裹节点使用wrap()方法; -&gt;将所有的元素单独包裹。 123&lt;strong&gt;hello world&lt;/strong&gt;$("strong").wrap("&lt;b&gt;&lt;/b&gt;"); //用b标签把strong元素包裹起来&lt;b&gt;&lt;strong&gt;hello world&lt;/strong&gt;&lt;/b&gt; wrapAll()和wrapInner()；（1）wrapAll。将所有匹配元素用一个元素来包裹，与wrap不同，wrap是将所有匹配元素单独包裹： 12345&lt;strong&gt;hello world&lt;/strong&gt;&lt;strong&gt;hello world&lt;/strong&gt;$("strong").wrap("&lt;b&gt;&lt;/b&gt;");&lt;b&gt;&lt;strong&gt;hello world&lt;/strong&gt;&lt;/b&gt;&lt;b&gt;&lt;strong&gt;hello world&lt;/strong&gt;&lt;/b&gt; 而使用wrapAll之后： 123456789101112131415&lt;b&gt;&lt;strong&gt;hello world&lt;/strong&gt;&lt;strong&gt;hello world&lt;/strong&gt;&lt;/b&gt;``` 注意：若被包裹元素之间有其他元素，则其他元素会被放到包裹元素之后 （2）wrapInner方法 该方法将每一个匹配的元素的子内容用其他结构化标记包裹起来： ```javascript&lt;strong&gt;hello world&lt;/strong&gt;$("strong").wrapInner("&lt;b&gt;&lt;/b&gt;");&lt;strong&gt;&lt;b&gt;hello world&lt;/b&gt;&lt;/strong&gt; 属性操作（1）获取和设置属性 使用attr()方法 获取属性12var $p = $("p"); //获取&lt;p&gt;节点var p_txt = $p.attr("title");//获取&lt;p&gt;元素节点属性title 设置属性 12345678910$("p").attr("title","value"); //用于设置单个属性$("p").attr(&#123;"title":"you title","name":"you name"&#125;); //用于设置多个属性，使用对象传递``` 注：类似这样的属性还有`html()`、`css()`、`text()`、`height()`、`widht()`、`val()`等方法。 （2）删除属性 使用`removeAttr()`方法 ```javascript$("p").removeAttr("title");//删除&lt;p&gt;元素的属性title 样式操作（1）获取样式和设置样式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用attr()方法（2）追加样式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用addClass()方法 12345678910111213141516171819202122232425$("p").addClass("another");//给&lt;p&gt;元素追加"another"类。``` **注：** &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(1)如果给一个元素添加了多个`class`值，那么就相当于合并了它们的样式。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(2)如果有不同的`class`设定了同一样式属性，则后者覆盖前者。 （3）移除样式 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用`removeClass()`,参数为要移除的`class`名，不带参数则把所有`class`移除 （4）切换样式 `toggle()`方法。 ```javascript$toggleBtn.toggle(function()&#123; // 显示元素 代码1&#125;,function()&#123; //隐藏元素 代码2&#125;);```` `toggle`的作用是，交替执行代码1和代码2，主要是用于控制行为上的重复切换 `toggleClass()`方法 用于控制样式上的切换，类名存在则删除，不存在则添加```javascript$("p").toggleClass("another"); （5）判断是否含有某个样式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasClass()方法用于判断是否含有某个class，有返回true，没有返回false 设置和获取HTML、文本和值（1）类似于JavaScript的innerHTML属性，可以用于获取和设置元素（传递参数）的HTML内容。注:可用于XHTML，不可用于XML。（2）text()方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似于JavaScript的innerText属性，用于获取和设置元素（传递参数）的文本内容。（3）val()方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似于JavaScript的value属性，用于设置和获取元素的值，无论元素是文本框，下来列表还是单选框，都可以返回元素值，若为多选，返回一个包含所有选择的值的数组。 遍历节点（1）children()方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取得匹配元素的子元素集合，只考虑子元素，不考虑后代元素。1$("p").children(); （2）next()方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于取得匹配元素后面紧邻的同辈元素。（3）prev()方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于取得匹配元素前面紧邻的同辈元素。1$("p").prev();//取得紧邻&lt;p&gt;元素前的同辈元素 （4）siblings()方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于取得匹配元素前后所有同辈元素。1$("p").siblings();//取得&lt;p&gt;元素的同辈元素 （5）closest()方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该方法用于取得最近的匹配元素。首先检查元素本身，接着逐级向上往祖先元素查找，没找到则返回空jQuery对象 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如，给点击的目标元素的最近的li元素添加颜色。如下： 123$(document).bind("click",function(e)&#123;$(e.target).closest("li").css("color","red");&#125;) （6）parent()，parents()，closest()区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent()，获取集合中每个匹配元素的父元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parents()，获取集合中每个匹配元素的祖先元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closese()，从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素 CSS-DOM操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以直接利用css()方法获取元素的样式属性：$(&quot;p&quot;).css(&quot;color&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论是外部CSS导入，还是直接拼接在HTML元素中，都可以通过css()方法获得&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置样式与attr()方法类似 12$("p").css("color","red"); //设置单个$("p").css(&#123;"color":"red","fontSize":"30px"); //设置多个 注：如果值是数字，则自动转化为像素值获取元素高度，可以直接使用height属性1$("p").height(); 注：1、jQuery1.2之后height可用于获取window和document的高度2、css方法获取的高度值与样式设置有关，而height获取的是元素在页面实际高度，与样式置无关，且不带单位与height对应的还有width()方法。 其他几个经常使用的方法： （1）offset()方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于获取元素在当前视窗的相对偏移，返回对象包含两个属性，top，left，只对可见元素有效。（2）position()方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于获取元素相对于最近一个position样式属性设置为elative或absolute的祖先节点的相对偏移，返回对象也包含连个属性top，left。（3）scrollTop()方法和scrollLeft()方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分别用于获取元素的滚动条距顶端和距左侧的距离，还可以接受一个参数，指定滚动条滚动到指定位置。 jQuery中的事件和动画jQuery中的事件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript中通常使用window.onload方法，jQuery中使用$(document).ready()方法。 1、执行时机&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.onload方法在网页所有元素都加载完毕之后才执行，$(document).ready()方法在DOM完全就绪就可以被调用 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于$(document).ready()方法内注册事件，只要DOM就绪就会被执行，因此有可能此时元素的关联文件还未下载完，例如图片的宽高可能无效。为解决此问题，使用jQuery另一个方法—–load()方法。load()方法会在元素的onload事件绑定一个处理函数。 123$(window).load(function()&#123; //编写代码&#125;); 等价于javascript中的以下代码： 123window.onload = function()&#123; //编写代码&#125;; 多次使用windows.onload()方法不能保存多个函数引用，而$(document).ready()可以 简写形式123$(document).ready(function()&#123; //编写代码&#125;); 简写123$(function()&#123; //编写代码&#125;); $(document)也可以简写为$()，当$()不带参数时，默认参数就是document，因此还可以简写： 123$().ready(function()&#123; // coding&#125;); 事件绑定使用bind()方法来对匹配元素进行特定事件绑定，调用格式：1bind(type [,datd] ,fn); 1.第一个参数是事件类型，类型包括：blur focus load resize scroll unload cliock dblclick mousedownmouseup mouseover mouseout mouseenter mouseleave change select submit keyup keydown keypress keyuperror2.第二个参数是可选参数，作为event.data属性值传递给事件对象的额外数据对象3.第三个参数则是用来绑定的处理函数使用：123$("#panel h5.head").bind("click",function()&#123; // coding&#125;); 合成事件jQuery有两个合成事件—hover()、toggle()，类似ready()，hover()和toggle()都是jQuery自定义方法1、hover()方法1hover(enter,leave) hover(fn1,fn2,...fnN)方法用于模拟光标悬停事件，当光标移动到元素上时，会触发第一个函数（enter），当光标移出这个元素时会触发第二个函数（leave）2、toggle()方法 —在jQuery1.9被移除toggle() 方法用于模拟鼠标的连续点击事件，第一次单击元素，触发第一个函数，第二次单击同一个元素，会触发第二个函数，如果有更多的函数，则依次触发，直到最后一个。 事件冒泡停止事件冒泡使用event.stopPropagation()可以停止事件冒泡 假设网页上有两个元素，其中一个嵌套在另一个元素里面，并且都被绑定了 click事件。同时 &lt;body&gt;元素上也绑定了click 事件，这样的话，点击最内层的元素，会触发三次 click事件。这是因为 JavaScript的事件冒泡机制。在 jQuery中，提供了 stopPropagation() 方法来停止冒泡。 阻止默认行为网页中的元素有自己的默认行为，例如点击超链接会跳转、单击提交按钮，表单会提交，有时需阻止事件默认行为jQuery中提供了preventDefault()方法来阻止默认行为event.preventDefault() 注：若想对事件对象停止冒泡和默认行为，可以在事件处理函数中返回false，这是对在事件对象上同时调用stopPropagation和preventDefault的一种简写方式 事件对象的属性 方法名称 描述 event.type 获取到事件的类型 event.preventDefault() 阻止默认的事件行为 stopPropagation() 阻止事件冒泡 event.tagent() 获取到触发事件的元素 event.relatedTarget() mousover 和 mouseout 所发生的元素 event.pageX event.pageY 获取到光标相对于页面的 x 坐标和 y 坐标 event.which() 鼠标单击事件中获取到的左、中、右键，在键盘事件中获取键盘的按键 event.metaKey() 为键盘事件获取ctrl键 移除事件1、移除按钮元素上以前注册的事件使用unbind()方法，语法结构：1unbind([type],[data]); 第一个参数是事件类型，第二个参数是要移除的函数&nbsp;&nbsp;&nbsp;&nbsp;（1）若没有参数，删除所有绑定事件&nbsp;&nbsp;&nbsp;&nbsp;（2）若提供了事件类型作为参数，则只删除该类型的绑定事件&nbsp;&nbsp;&nbsp;&nbsp;（3）若都传递，则只有这个特定的事件处理函数会被删除 one() 方法对于只要触发一次，随后要立即解除绑定的情况，jQuery提供了 one() 方法。当处理函数触发一次后，立即被删除。 模拟操作1、常用模拟使用trigger()方法完成模拟操作：123456789101112$("#btn").trigger("click"); // 触发id为btn的click事件// 也可以简化：$("#btn").click();``` 2、触发自定义事件 `trigger()`方法不仅可触发浏览器支持的具有相同名称的事件，也可以触发自定义名称的事件 例： ```javascript$('#btn').bind("myClick",function()&#123; $('#test').append("&lt;p&gt;我的自定义事件&lt;/p&gt;");&#125;);$('#btn').trigger("myClick"); 3、传递数据 1234$('#btn').bind("myClick",function(event,message1,message2)&#123; $('#test').append("&lt;p&gt;"+message1+message2+"&lt;/p&gt;");&#125;);$('#btn').trigger("myClick",["我的自定义","事件"]); 4、执行默认操作 trigger()方法触发事件后，还会执行浏览器默认操作 1$('input').trigger("focus"); 不仅会触发绑定在input上的事件，也会使input元素获得焦点使用triggerHandler()方法可以只触发事件，而不执行浏览器默认操作 1$('input').triggerHandler("focus"); 只会触发绑定事件，不会是input元素获得焦点 其他用法1、绑定多个事件类型12345$(function()&#123; $("div").bind("mouseout mouseover",function()&#123; //do something &#125;);&#125;; 2、添加事件命名空间，便于管理1234567891011121314151617181920212223242526272829$(function()&#123; $('div').bind("click.plugin",function()&#123; $('body').append("&lt;p&gt;click事件&lt;/p&gt;"); &#125;); $('div').bind("mouseover.plugin",function()&#123; $('body').append("&lt;p&gt;mouseover事件&lt;/p&gt;"); &#125;); $('div').bind("dbclick",function()&#123; $('body').append("&lt;p&gt;dbclick事件&lt;/p&gt;"); &#125;); $('button').click(function()&#123; $('div').unbind(".plugin"); &#125;);&#125;);``` 在所绑定的事件后面添加命名空间，删除时只需要指定命名空间即可，单击`&lt;button&gt;`后，plugin的命名空间被删除，而不再`plugin`空间中的`dbclick`事件依然存在 3、相同事件名称，不同命名空间执行方法 ```javascript$(function()&#123; $('div').bind("click",function()&#123; $('body').append("&lt;p&gt;click事件&lt;/p&gt;"); &#125;); $('div').bind("click.plugin",function()&#123; $('body').append("&lt;p&gt;click.plugin事件&lt;/p&gt;"); &#125;); $('button').click(function()&#123; $('div').trigger("click!"); //注意感叹号 &#125;);&#125;); 单击&lt;div&gt;元素后，会同时触发click事件和click.plugin事件，若只单击则只触发click事件，不触发click.plugin事件，注意trigger(&quot;click!&quot;)后面的感叹号的作用是匹配所有不包含命名空间中的click方法若两者都要触发，改为如下代码：1$("div").trigger("click"); jQuery中的动画 方法名 说明 hide() show() 同时修改多个样式属性，即高度、宽度和不透明度 fadeIn() fadeOut() 只改变不透明度 slideUp() slideDown() 只改变高度 toggle() 用来代替 hide() 和 show() 方法 slideToggle() 用来代替 slideUp() 和 slideDown() fadeToggle() 用来代替 fadeIn() 和 fadeOut() animate() 属于自定义动画的方法 1、show()方法和hide()方法 （1）show()方法和hide()方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用hide()方法会将该元素的display样式改为“none”元素隐藏后可以使用show()方法将元素的display样式设置为先前的显示状态（2）show()方法和hide()方法让元素动起来&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;希望调用show()方法时元素慢慢地显示出来，可以为show()方法指定一个速度参数，例如，速度关键字“slow” 12345678910111213$(“element”).show("slow");``` 元素会在`600ms`内慢慢显示，还有`normal（400ms）`，`fast（200ms）`，还可以指定一个数字（单位是毫秒） ```javascript$(function()&#123; $("#panel h5.head").toggle(function()&#123; $(this).next().show("slow"); &#125;,function()&#123; $(this).next().hide(1000); &#125;);&#125;); 2、fadeIn()方法和fadeOut()方法 fadeIn(),fadeOut()只改变元素的不透明度，fadeOut()会在指定的时间内降低元素的不透明度，直至元素完全消失（display:none），fadeIn()相反。1234567$(function()&#123; $("#panel h5.head").toggle(function()&#123; $(this).next().fadeOut(); &#125;,function()&#123; $(this).next().fadeIn(); &#125;);&#125;); 也可以使用关键字和指定时间参数，单位毫秒 3、slideUp()方法和slideDown()方法 这两个方法只会改变元素的高度，若一个元素的display为none，slideDown()会将这个元素自上而下延伸显示，slideUp()正好相反 123456789101112131415161718192021222324252627282930313233343536$(function()&#123; $("#panel h5.head").toggle(function()&#123; $(this).next().slideDown(); &#125;,function()&#123; $(this).next().slideUp(); &#125;);&#125;);``` 一样可以使用关键字和指定时间参数，单位毫秒 ### 自定义动画方法animate()```javascript animate(params, speed, callback);``` （1）`params`：一个包含样式属性及值的映射，例：`&#123;property:"value",property:"value1",....&#125; ` （2）`speed`：速度参数，可选 （3）`callback`：动画完成时执行的函数，可选 1、自定义简单动画 ```javascript#panels&#123; position: relative; width: 100px; height: 100px; border: 1px solid #0050d0; background: #96e555; cursor: pointer;&#125;&lt;div id="panels"&gt;&lt;/div&gt;$(function()&#123; $("#panels").click(function()&#123; $(this).animate(&#123;left:"500px"&#125;,3000); &#125;);&#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三秒之内，div右移500px，只会移动一次 2、累加、累减动画 12345$(function()&#123; $("#panels").click(function()&#123; $(this).animate(&#123;left:"+=500px"&#125;,3000); &#125;);&#125;); 3、多重动画（1）同时执行多个动画12345$(function()&#123; $("#panels").click(function()&#123; $(this).animate(&#123;left:"500px",width:"200px",height:"200px"&#125;,3000); &#125;);&#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是同时执行的动画 （2）按顺序执行多个动画 把多个动画拆开即可 1234567 $(function()&#123; $("#panels").click(function()&#123; $(this).animate(&#123;left:"500px"&#125;,3000); $(this).animate(&#123;width:"200px"&#125;,3000); $(this).animate(&#123;height:"200px"&#125;,3000); &#125;);&#125;); 链式写法：1234567$(function()&#123; $("#panels").click(function()&#123; $(this).animate(&#123;left:"500px"&#125;,3000) .animate(&#123;width:"200px"&#125;,3000) .animate(&#123;height:"200px"&#125;,3000); &#125;);&#125;); 4、综合动画12345678$(function()&#123; $("#panels").css("opacity","0.5");//设置不透明度 $("#panels").click(function()&#123; $(this).animate(&#123;left:"400px",height:"200px",opacity:"1"&#125;,3000) .animate(&#123;top:"200px",width:"200px"&#125;,3000) .fadeOut("slow"); &#125;);&#125;); 5、动画回调函数若想在最后完成时改变CSS样式，而不是淡出，则需要使用回调函数，而不是将css()方法写在fadeOut()方法的位置，因为css()方法并不会加入动画队列 123456789$(function()&#123; $("#panels").css("opacity","0.5");//设置不透明度 $("#panels").click(function()&#123; $(this).animate(&#123;left:"400px",height:"200px",opacity:"1"&#125;,3000) .animate(&#123;top:"200px",width:"200px"&#125;,3000,function()&#123; $(this).css("border","5px solid blue"); &#125;); &#125;);&#125;); 注：callback回调函数适合jQuery的所有动画效果 停止动画和判断是否处于动画状态1、停止元素的动画使用stop()方法1stop([clearQueue],[gotoEnd]); 参数均为可选参数，为boolean值clearQueue表示是否清空动画队列，gotoEnd表示直接将正在执行的动画跳转到末状态如果直接使用stop()方法，则会立即停止正在执行的动画，若还有动画等待执行，则以当前状态继续执行下一个动画 2、判断元素是否处在动画状态12345678910111213141516171819202122232425262728if(!$("element").is(":animate"))&#123; //do something&#125;``` 3、延迟动画 使用`delay()`方法可以对动画进行延迟操作 ```javascript$(function()&#123; $("#panels").css("opacity","0.5");//设置不透明度 $("#panels").click(function()&#123; $(this).animate(&#123;left:"400px",height:"200px",opacity:"1"&#125;,3000) .delay(1000) // 延迟的是下一个动画 .animate(&#123;top:"200px",width:"200px"&#125;,3000); &#125;);&#125;);``` 其他动画方法 1、`toggle(speed,[callback])`方法 2、`slideToggle(speed,[easing],[callback])`; 3、`fadeTo(speed,opacity,[callback])`; 4、`fadeToggle(speed,[easing],[callback])`; *1、`toggle()` *可切换元素的可见状态 ```javascript $("#panel h5.head").click(function()&#123; $(this).next().toggle();&#125;); 等价于：1234567$(function()&#123; $("#panel h5.head").toggle(function()&#123; $(this).next().show("slow"); &#125;,function()&#123; $(this).next().hide(1000); &#125;);&#125;); 2、slideToggle()方法通过高度变化切换匹配元素可见性3、fadeTo()方法把元素的不透明度以渐进方式调整到指定值，只调整元素的不透明度，4、fadeToggle()方法通过元素不透明度变化来切换元素的可见性，只调整元素的不透明度 jQuery与Ajax的应用Ajax的优势和不足Ajax的优势1、不需要插件支持2、优秀的用户体验3、提高Web程序的性能4、减轻服务器和带宽的负担 Ajax的不足1、浏览器对XMLHttpRequest对象的支持度不足2、破坏浏览器前进、后退按钮的正常功能3、对搜索引擎的支持的不足4、开发和调试工具的缺乏 Ajax的XMLHttpRequest对象Ajax的核心是XMLHttpRequest对象，它是Ajax实现的关键—-发送异步请求、接收响应及执行回调都是通过它来完成的。IE5、IE6是以ActiveXObject的方式引入XMLHttpRequest对象的，而其他浏览器的XMLHttpRequest对象是window的子对象 使用原生 JS 写一个 Ajax 一. 定义一个函数，通过该函数来获取异步信息123function Ajax()&#123; //定义一个函数，通过该函数来获取异步信息&#125; 声明一个空对象来装入 XMLHttpRequest 对象 var xmlHttpReq = null; // 声明一个空对象来装入 XMLHttpRequest 对象 二. 实例化一个 XMLHttpRequest 对象1234if(window.XMLHttpRequest)&#123; xmlHttpReq = new XMLHttpRequest(); // 实例化一个 XMLHttpRequest 对象&#125; 使用 open() 方法初始化 XMLHttpRequest 对象，指定 HTTP 方法和要使用的服务器 URL; 12xmlHttpReq.open("GET","test.php",true); // 调用 open() 方法并采用异步方式 使用 onreadystatechange 属性来注册该回调事件处理器，当 readystatus 状态改变时，会激发 onreadystatechange事件然后调用回调函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169 xmlHttpReq.onreadystatechange = RequestCallBack; ``` 使用 `send()` 方法发送请求，使用 `GET`方式可以不指定参数或者使用 `null `参数`xmlHttpReq.send(null)`; 当请求状态改变时，`XMLHttpRequest` 对象调用 `onreadystatechange` 属性注册的事件处理器，在处理响应之前，事件处理器应该首先检查 `readyStatus `的值和` HTTP `状态。当请求完成加载`（readyStatus == 4）`并且响应已经成功`（HTTP 状态值为 200）`，就可以处理响应内容； ```javascriptfunction RequestCallBack() &#123; if(xmlHttpReq.readyState == 4)&#123; if(xmlHttpReq.status == 200)&#123; document.getElementById("resText").innerHTML = xmlHttpReq.responseText; &#125; &#125;&#125; ``` ## jQuery中的Ajax `jQuery` 对 `Ajax` 操作进行封装，在 `jQuery `中，`$.ajax() `是最底层的方法，第二层是 `load()`、`$.get()`、`$.post()`、`$.grtJSON()`。 **1、load()方法** 语法结构：`load(url [,data] [,callback]) `**load()方法参数解释** 参数 | 类型---|---url | Stringdata（可选） | Objectcallback（可选） | Function筛选载入的`HTML`文档```javascript$('#resText').load("test.html .para"); // 载入test.html页面中class为“para”的内容``` **传递方式** `load()`方法会根据参数`data`来自动指定，有参数传递为`POST`方式，无参数则为`GET`方式 **回调函数** 有3个参数：1、请求返回的内容；2、请求的状态；3、`XMLHttpRequest`对象 **注**：通常用于从`Web`服务器获取静态文件 **2、$.get()与$.post()方法** （1）`$.get()`使用`GET`方式来进行异步请求 语法结构：`$.get(url [,data] [,callback] [,type]); `**$.get()方法参数解释** 参数 | 类型---|---url | Stringdata（可选） | Objectcallback（可选）） | Functiontype（可选） | String**回调函数** 只有两个参数：1、`data`，返回的内容，`xml`文档，`json`文件等；2、请求状态：`success`、`error`、`notmodified`、`timeout` **注**：只有当数据成功返回`(success)`才被调用 （2）`$.post()`使用`POST`方式进行异步请求 ` $.post( url [, data] [, callback] [, type]) ` **GET与POST的区别** &lt;1&gt;`GET`请求会将参数跟在`URL`后进行传递，`POST`则是作为`HTTP`实体内容发送个`Web`服务器。 &lt;2&gt;`GET`对传输数据有大小限制（通常不大于`2kb`），而`POST`则要比`GET`多的多（理论上不限制） &lt;3&gt;`GET`请求会被浏览器缓存下来，在某种情况下会有严重的安全性问题，而`POST`则可避免 &lt;4&gt;`GET`与`POST`传递的数据在服务器端获取方式也不相同 **3、$.getScript()方法和$.getJson()方法** `（1）$.getScript()` 使用`$.getScript()`方法加载一个`js`文件就跟加载一个`HTML`页面一样简单，而且不需要对`js`文件进行处理，`js`文件会自动执行 **回调函数** 会在`js`加载成功后执行 （2）`$.getJson()` `$.getJson()`用于加载`json`文件 `$.each()`方法，`jQuery`中用于遍历对象和数组，接受两个参数：1、数组或对象；2、回调函数（接受两个参数：1、对象成员或数组索引；2、对应变量或内容） **4、$.ajax()方法** `$.ajax()` 方法是 `jQuery` 最底层的 `Ajax` 实现， `$.ajax(option)` 参数名称 | 类型 | 说明---|--- |---url | String | 发送请求的 URL（默认为当前页面）type | String | 请求方式，默认为 GETtimeout | Number | 设置请求超时时间（毫秒）data | Object 或 String | 发送到服务器的数据dataTpye | String | 预期服务器返回的数据类型beforeSend | Function | 发送请求前可以修改 XMLHttpResponse 对象的函数complete | Function | 请求完成后调用的回调函数（请求失败或者成功均调用）success | Function | 请求成功后调用的回调函数error | Function | 请求失败后调用的回调函数global | Function | 默认为 true。是否触发全局 Ajax 事件## 序列化元素**1、serialize()方法** 作用于一个`jQuery`对象，能够将`DOM`元素内容序列化为字符串，用于`Ajax`请求 **注**：参数传递时要注意将参数进行编码，即使用`URI`编码，若不希望编码带来麻烦，可以使用`serialize()`方法，它会自动编码 **2、serializeArray()方法** 将`DOM`序列化后，返回`json`格式数据 **3、$.param()方法** `serialize()`方法核心，用以对一个对象按照`key/value`进行序列化 ## jQuery中的Ajax全局事件 当`Ajax`请求开始时，触发`ajaxStart()`方法的回调函数；当`Ajax`请求结束时，触发`ajaxStop()`方法的回调函数 其他的全局方法 方法名称 | 说明---|---ajaxComplete(callback) | Ajax请求完成时执行函数ajaxError(callback) | Ajax请求发生错误时执行函数，捕捉到的错误可以作为最后一个参数传递ajaxSend(callback) | Ajax请求发送前执行的函数ajaxSuccess(callback) | Ajax请求成功时执行函数## jQuery 性能优化1、使用最新版的`jQuery`类库 2、使用合适的选择器（1、尽量使用id选择器，2、尽量给选择器指定上下文） 3、缓存对象（即使用一个变量将需要重复使用的`jQuery`对象存下来，以避免多次获取） 4、循环时的`DOM`操作（减少`DOM`操作） 5、数组方式使用`jQuery`对象（尽量使用`for`或`while`循环来处理`jQuery`对象，而不是使用`$.each()`） **注**：检查`jQuery`对象是否存在的方式应该使用`length`属性 6、事件代理 7、将代码转化为`jQuery`插件 8、使用`join()`来拼接字符串，替代使用`“+”`来拼接 9、合理利用`HTML5`的`Data`属性 10、尽量使用原生的`JavaScript`方法 11、压缩`JavaScript` ### 使用合适的选择器 1. `$(“#id”)` `id` 选择器无疑是最佳提高性能的方式。因为 `jQuery `底层直接调用本地方法` document.getElementById()`，直接通过 `id `返回对应的元素可以有效的缩小你定位的` DOM `元素，建议从最近的 `ID `元素开始往下搜索。 2. `$(“p”)`、`$(“div”)`、`$(“input”) `标签选择器是性能优化第二选择，因为` jQuery` 也是直接调用` JS `原生方法 3. `$(“.class”)` 这是 `jQuery` 封装的函数，`ie9+` 以上是使用 `JS` 的原生方法，`ie9` 一下是使用 `DOM` 搜索方式来实现 4. `$(“[attribute=value]”)`：利用属性来定位` DOM` 元素，大部分都是使用` DOM `搜索方式来达到效果。所以性能并不是很理想 5. `$(“:hidden”)`：这和上面利用属性类似，并且` jQuery` 需要搜索每一个元素来定位这个选择器，所以尽量不要使用。 ### 缓存对象 我们可以将经常用的对象使用变量缓存起来，因为 `jQuery `会在创建每一个选择器的过程中，查找 `DOM`。 **不要让相同的选择器在你的代码中出现多次。** ### 循环时的 DOM 操作 在一些循环时，例如 `for()`、`while()`、`$.each()` 使用这些方法处理` DOM` 元素时，要尽可能的减少操作 `DOM`，可以使用变量将来储存元素，最后一次性将生产的` DOM `插入或者删除。 ### 数组方式使用 jQuery 对象使用 `jQuery` 选择器获得的结果是一个 `jQuery` 对象，然而，`jQuery`类库会让你感觉你正在使用一个定义了索引和长度的数组。在性能方面，建议使用 `for` 或者 `while` 循环来处理，而不是 `$.each()`### 事件代理 每一个 `JavaScript` 事件（例如：`click`、`mouseover` 等）都会冒泡到父节点，当我们需要给多个元素调用同个函数时会很有用。 比如，我们要单击表格的行使得改行背景颜色改变 ```javascript$("myTable td").click(function()&#123; $(this).css("background",'red')&#125;)``` 如果你是这样写的话，那么恭喜你，提供了一个错误的示例，🎉🎉。这样的弊端是，假使总共有` 100` 个` td`，那么在使用以上方式的时候，你绑定了` 100` 个事件，天辣，是不是很恐怖。 正确的姿势是，只需要向他们的父节点绑定一次事件，然后通过 `event.target` 获取到当前点击的元素。 ```javascript$("myTable").click(function()&#123; var $clicked = $(e.target); // 捕捉到触发的目标元素 $clicked.css("background",'red');&#125;) 也可以这样写 123$("myTable td").on('click','td', function()&#123; $(this).css("background",'red')&#125;)]]></content>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
</search>
