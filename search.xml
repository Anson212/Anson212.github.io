<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue组件化开发学习(一)]]></title>
    <url>%2F2019%2F07%2F14%2Fvue%2Fvue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[什么是组件化 人面对复杂问题的处理方式： 任何一个人处理信息的逻辑能力都是有限的 所以，当面对一个非常复杂的问题时，我们不太可能一次性搞定一大堆的内容。 但是，我们人有一种天生的能力，就是将问题进行拆解。 将一个复杂的问题，拆分成很多个可以处理的小问题，再讲其放在整体当中，你就会发现大的问题也会迎刃而解。 组件化也是类似的思想： 如果我们将一个野蛮中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展。 但如果我们把一个页面拆分成一个个小的功能块，那每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就会变得非常容易了。 Vue组件化思想 组件化是vue.js中的重要思想 它提供了一种抽象，可以让我们开发出一个个独立可复用的小组件来构造我们的应用。 任何的应用都会抽象成一颗组件树。 组件化思想的应用： 有了组件化的思想，在之后的开发中就要充分的利用它。 尽可能的将页面拆分成一个个小的，可复用的组件。 这样让我们的代码更加方便组织和管理，并且扩展性也更强。 组件是Vue开发中，非常重要的一个编章需要认真的学习。 注册成组件的基本步骤 组件的使用分成三个步骤： 创建组件构造器 注册组件 使用组件 123456789101112131415161718192021&lt;div id="app"&gt;&lt;!--3.使用组件--&gt;&lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt;&lt;script src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; //1.创建组件构造器对象 const myComponent = Vue.extend(&#123; template:` &lt;div&gt; &lt;h2&gt;组件标题&lt;/h2&gt; &lt;p&gt;我是组件中的一个段落内容&lt;/p&gt; &lt;/div&gt; ` &#125;) //2.注册组件，并且定义组件标签的名称 Vue.component('my-cpn',myComponent) const app = new Vue(&#123; el:"#app" &#125;)&lt;/script&gt; 组件步骤解析 上面代码的步骤都代表什么含义呢？ 1.Vue.extend(): 调用Vue.extend()创建的是一个组件构造器。 通常在创建组件构造器时，传入template代表我们自定义组件的模板。 该模板就是在使用到组件的地方，要显示的HTML代码。 事实上，这种写法在Vue2.x的文档中几乎已经看不到了，它会直接使用下面的Vue.component()这种方式，而且这种方式是学习Vue.component()这种方式的基础。 2.Vue.component(): 调用Vue.component()是将该刚才的组件构造器注册为一个组件，并给它起一个组件的标签名称。所以需要传递两个参数：1、注册组件的标签名 2、组件构造器 3.组件必须挂载在某个Vue实例下，否则它不会生效。 全局组件和局部组件 当我们通过调用Vue.component()注册组件时，组件的注册是全局的 这意味着该组件可以在任意Vue示例下使用。 如果我们注册的组件是挂载在某个实例中，那么就是一个局部组件 全局使用组件1234567891011121314151617181920212223242526&lt;div id=&quot;app1&quot;&gt;&lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt;&lt;div id=&quot;app2&quot;&gt;&lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.创建组件构造器 const myComponent = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;组件标题&lt;/h2&gt; &lt;p&gt;组件正文内容,今天天气真好！&lt;/p&gt; &lt;/div&gt; ` &#125;) // 2.注册组件(全局组件, 意味着可以在多个Vue的实例下面使用) Vue.component(&apos;my-cpn&apos;, myComponent) let app1 = new Vue(&#123; el: &apos;#app1&apos; &#125;) let app2 = new Vue(&#123; el: &apos;#app2&apos; &#125;)&lt;/script&gt; 局部使用组件 1234567891011121314151617181920212223242526272829&lt;div id="app1"&gt;&lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt;&lt;div id="app2"&gt;&lt;!--没有被渲染出来--&gt;&lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt;&lt;script src="../js/vue.js"&gt;&lt;/script&gt;&lt;script&gt; // 1.创建组件构造器 const myComponent = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;组件标题&lt;/h2&gt; &lt;p&gt;组件正文内容,今天天气真好！&lt;/p&gt; &lt;/div&gt; ` &#125;) let app1 = new Vue(&#123; el: '#app1', components:&#123; 'my-cpn': myComponent &#125; &#125;) let app2 = new Vue(&#123; el: '#app2' &#125;)&lt;/script&gt; 注册组件语法糖 在上面注册组件的方式，可能会有些繁琐。 Vue为了简化这个过程，提供了注册的语法糖。 主要是省去了调用Vue.extend()的步骤，而是可以直接使用一个对象来代替。 下面就看一下语法糖注册全局组件和局部组件： 语法糖注册全局组件和局部组件： 1234567891011121314151617181920212223242526272829303132&lt;div id="app"&gt;&lt;my-cpn1&gt;&lt;/my-cpn1&gt;&lt;my-cpn2&gt;&lt;/my-cpn2&gt;&lt;/div&gt;&lt;script src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;//1.全局组件注册的语法糖Vue.component('my-cpn1',&#123; template: ` &lt;div&gt; &lt;h2&gt;组件标题&lt;/h2&gt; &lt;p&gt;组件正文内容,今天天气真好!&lt;/p&gt; &lt;/div&gt; `&#125;)//2.注册局部组件的语法糖const app = new Vue(&#123; el:"#app", data:&#123;&#125;, components:&#123; 'my-cpn2':&#123; template: ` &lt;div&gt; &lt;h2&gt;组件标题&lt;/h2&gt; &lt;p&gt;组件正文内容,今天真开心啊!&lt;/p&gt; &lt;/div&gt; ` &#125; &#125;&#125;)&lt;/script&gt; 组件数据的存放 组件自己的数据存放在哪里呢？ 组件对象也有一个data属性(也可以有methods等属性)。 只是这个data属性必须是一个函数 而且这个函数返回一个对象，对象内部保存着数据 12345678910111213141516171819202122232425&lt;div id="app"&gt;&lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt;&lt;template id="myCpn"&gt;&lt;div&gt; &lt;h2&gt;消息：&#123;&#123;massage&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;/template&gt;&lt;script src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;const app = new Vue(&#123; el: "#app", components: &#123; "my-cpn": &#123; template: '#myCpn', data() &#123; return &#123; massage: 'Hello World' &#125; &#125; &#125; &#125;&#125;)&lt;/script&gt; 为什么data在组件中必须是一个函数呢？ 首先，如果不是一个函数，Vue直接就会保错。 其次，原因是在于Vue每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响。 父子组件的通讯 在开发中，往往一些数据确实需要从上层传递到下层： 比如在一个页面中，我们从服务器请求到很多数据。 其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示。 这个时候，并不会让子组件再次发送一个网络请求，而是直接让大组件(父组件) 将数据传递给小组件(子组件) 如何进行父子组件间的通讯？Vue官方提到 通过props向子组件传递数据 通过事件向父组件发送消息 props基本用法 在组件中，使用选项props来声明需要从父级接收到的数据。 props的值有两种方式： 方式一： 字符串数组，数组中的字符串就是传递时的名称 方式二：对象，对象可以设置传递时的类型，也可以设置默认值等 下面是一个最简单的props传递方式 123456789101112131415161718192021&lt;div id="app"&gt;&lt;child-cpn :message="message"&gt;&lt;/child-cpn&gt;&lt;/div&gt;&lt;template id="childCpn"&gt; &lt;div&gt;显示的信息:&#123;&#123;massage&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const app = new Vue(&#123; el:"#app", data:&#123; //Vue实例中的data message:"Hello World" &#125;, components: &#123; "child-cpn":&#123; // 子组件中的props template: "#childCpn", props::['message'] &#125; &#125; &#125;)&lt;/script&gt; props数据验证 除了数组之外，我们也可以使用对象，当需要对props 进行类型等验证时 ，就需要对象的写法。 验证都支持哪些数据类型呢？ 如下： String Number Boolean Array Object Data Function Symbol 当我们有自定义构造函数时，验证页支持自定义的类型 父级向子级传递123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div id="app"&gt;&lt;cpn :cmessage="message" :cmovies="movies"&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id="cpn"&gt;&lt;div&gt; &lt;ul&gt; &lt;li v-for="item in cmovies"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&#123;&#123;cmessage&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;/template&gt;&lt;script src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; //创建子组件 const cpn = &#123; template:"#cpn", props:&#123; //1.类型限制 //2.提供一些默认值，以及必传值 cmessage:&#123; type: String, default: '', required: true &#125;, // 类型是对象或者数组时，默认值必须是一个函数 cmovies:&#123; type: Array, default()&#123; return [] &#125; &#125; &#125; &#125; const app = new Vue(&#123; el:"#app", data:&#123; message:"Hello World", movies: ['Vue.js', 'React', 'Angular'] &#125;, components:&#123; cpn &#125; &#125;)&lt;/script&gt; 子级向父级传递 props用于父组件向子组件传递数据，还有一种比较常见的是子组件传递数据或者事件到父组件中。 应该如何处理？这时候需要使用自定义事件来完成。 什么时候需要自定义事件呢？ 当子组件需要向父组件传递数据时，就要用到自定义事件。 之前学习的v-on不仅仅可以用于监听DOM事件，也可以用于组件间的自定义事件。 自定义事件的流程： 在子组件中，通过$emit()来触发事件。 在父组件中，通过v-on来监听子组件事件。 简单的例子： 通过两个按钮+1和-1，点击后修改counter。 整个操作的过程还是在子组件中完成，但是之后的展示交给父组件。 这样，我们就需要将子组件中的counter，传给父组件的某个属性，比如total 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div id="app"&gt;&lt;child-cpn @increment="changeTotal" @decrement="changeTotal"&gt;&lt;/child-cpn&gt;&lt;h2&gt;点击次数: &#123;&#123;total&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;template id="childCpn"&gt; &lt;div&gt; &lt;button @click="increment"&gt;+1&lt;/button&gt; &lt;button @click="decrement"&gt;-1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const app = new Vue(&#123; el:"#app", //vue实例 data:&#123; total:0 &#125;, methods:&#123; changeTotal()&#123; this.total = counter &#125; &#125;, components:&#123; 'child-cpn':&#123; template:"#childCpn", data()&#123; return &#123; counter: 0 //子组件 &#125; &#125;, methods:&#123; increment()&#123; this.counter++; this.$emit("increment", this.counter) &#125;, decrement()&#123; this.counter++; this.$emit("decrement", this.counter) &#125; &#125; &#125; &#125; &#125;)&lt;/script&gt; 父子组件的访问方式:$refs$refs的使用： $refs和ref指令通常是一起使用的。 首先，我们通过ref给某一个子组件绑定一个特定的ID。 其次，通过this.$refs.ID就可以访问到该组件了。 123&lt;child-cpn1 ref="child1"&gt;&lt;/child-cpn1&gt;&lt;child-cpn2 ref="child2"&gt;&lt;/child-cpn2&gt;&lt;button @click="showRefsCpn"&gt;通过$refs访问子组件&lt;/button&gt; 1234showRefsCpn()&#123; console.log(this.$refs.child1.message) console.log(this.$refs.child2.message)&#125; 非父子组件通讯 在Vue2.x中，有一种方案是通过中央事件总线，也就是一个中介来完成。 但是这种方案和直接使用Vuex的状态管理方案还是逊色很多。 并且Vue提供了更多好用的功能，所有我们这里就简单的了解一下。 简单的例子：比如在A,B组件为兄弟组件，现在A组件要调用B组件中的C事件 1.创建一个bus.js 123import Vue from 'vue'const Bus = new Vue()export &#123;Bus&#125; 2.在A,B组件中引入bus.js 1import &#123; Bus &#125; from 'bus' 3.在A组件中定义要调用B事件的bus事件名 1例如: Bus.$emit('callC') 4.在B组件中调用C方法 1Bus.$on('callC',this.C) Bus.$on里面有两个参数，第一个是在A组件定义的名字，第二个参数是B组件要调用的方法。 ==总结：== 以上所述的是vue中组件化的理解，希望对大家有所帮助！！！]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中v-model的使用]]></title>
    <url>%2F2019%2F07%2F13%2Fvue%2Fvue%E4%B8%AD%E7%9A%84v-model%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[vue中的v-mdoel的应用 v-model用于表单数据的双向绑定，其实它就是一个语法糖。 vue中经常使用到表单绑定例如：&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;、&lt;radio&gt;、&lt;checkbox&gt;这类表单元素，vue对于这些元素的数据绑定跟我们以前经常使用的jquery有些区别。vue使用v-model实现这些标签的双向绑定，会根据控件类型自动选取正确的方法来更新元素。 表单绑定v-model 表单控件在实际开发中是非常常见的。特别是对于用户信息的提交，需要大量的表单。 Vue中使用v-model指令来实现表单元素和数据的双向绑定。 案例分析： 当我们在输入框输入内容时 因为input中的v-model绑定了message，所以会实时将输入的内容传递给message，message发生改变。 当message发生改变时，因为上面我们使用Mustache语法，将message的值插入到DOM中，所以DOM会发生响应的改变。 所以，通过v-model实现了双向的数据绑定 。 1234567891011121314&lt;div id="app"&gt; &lt;input type="text" v-model="message" /&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const app = new Vue(&#123; el:"#app", data:&#123; message:"你好,v-model" &#125; &#125;)&lt;/script&gt; v-model原理 v-model其实是一个语法糖，它的背后本质上是包含两个操作 1.v-bind绑定一个value属性 2.v-on指令给当前元素绑定input事件 也就是说下面的代码：等同于下面的代码 1234&lt;input type="text" v-model="message" /&gt;&lt;!--等同于下面--&gt;&lt;input type="text" :value="message" @input="message = $event.target.value" /&gt; v-model的修饰符 v-model修饰符与事件的修饰符类似，用于控制同步的时机 .lazy修饰符 在输入框中，v-model是默认在input事件中同步输入框的数据。 使用修饰符.lazy会转变为在change事件中同步。 在失去焦点或者按回车才更新。 1234567891011121314&lt;div id="app"&gt; &lt;input type="text" v-model.lazy="message" /&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const app = new Vue(&#123; el:"#app", data:&#123; message:"你好,v-model" &#125; &#125;)&lt;/script&gt; .number修饰符 使用修饰符number可以将输入转换成Number类型，否则不管是否输入数字，其实都是String。 默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。 但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。 number修饰符可以让在输入框中输入的内容自动转成数字类型。 1234567891011121314&lt;div id="app"&gt; &lt;input type="text" v-model.number="message" /&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const app = new Vue(&#123; el:"#app", data:&#123; message:"123456789" &#125; &#125;)&lt;/script&gt; .trim修饰符 修饰符.trim 可以自动过滤输入的首位空格。 如果输入的内容首尾有很多空格，通常我们希望将其去除 trim修饰符可以过滤内容左右两边的空格。 1234567891011121314&lt;div id="app"&gt; &lt;input type="text" v-model.trim="message" /&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const app = new Vue(&#123; el:"#app", data:&#123; message:"123456789" &#125; &#125;)&lt;/script&gt; v-model:radio的案例 当存在多个单选框时 12345678910111213141516171819&lt;div id="app"&gt; &lt;label for="male"&gt; &lt;input type="radio" id="male" value="男" v-model="sex"/&gt;男 &lt;/label&gt; &lt;label for="female"&gt; &lt;input type="radio" id="female" value="女" v-model="sex"/&gt;女 &lt;/label&gt; &lt;h2&gt;您选择的性别是：&#123;&#123;sex&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const app = new Vue(&#123; el:"#app", data:&#123; sex:"男" &#125; &#125;)&lt;/script&gt; v-model:checkbox的案例 复选框分为两种情况：单个勾选框和多个勾选框 单个勾协框： v-model即为布尔值。 此时input的value并不影响v-model的值。 多个复选框： 当是多个复选框时，因为可以选中多个，所以对应的data中的属性是一个数组。 当选中某一个时，就会将input的value添加到数组中去。 123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;!--单个复选框--&gt; &lt;label for="check"&gt; &lt;input type="checkbox" v-model="checked" id="check"/&gt;同意协议 &lt;/label&gt; &lt;p&gt;是否选中：&#123;&#123;checked&#125;&#125;&lt;/p&gt; &lt;!--多个复选框--&gt; &lt;input type="checkbox" value="篮球" v-model="hobbies" /&gt; 篮球 &lt;input type="checkbox" value="足球" v-model="hobbies" /&gt;足球 &lt;input type="checkbox" value="兵兵球" v-model="hobbies" /&gt;兵兵球 &lt;input type="checkbox" value="羽毛球" v-model="hobbies" /&gt;羽毛球 &lt;h2&gt;您的爱好是： &#123;&#123;hobbies&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const app = new Vue(&#123; el:"#app", data:&#123; checked: false, //单选框 hobbies: [], //多选框 &#125; &#125;)&lt;/script&gt; v-model:select的案例 和checkbox一样，select也分单选和多选两种情况。 单选：只能选中一个值。 v-model绑定的是一个值。 当我们选中option中的一个值时，会将它对应的value赋值mySelect中 多选：可以选中多个值 v-model绑定的是一个数组。 当选中多个值时，就会将选中的option对应的value添加到数组mySelects中去 123456789101112131415161718192021222324252627282930&lt;div id="app"&gt; &lt;!--1.选择一个值--&gt; &lt;select name="abc" v-model="mySelect"&gt; &lt;option value="苹果"&gt;苹果&lt;/option&gt; &lt;option value="香蕉"&gt;香蕉&lt;/option&gt; &lt;option value="榴莲"&gt;榴莲&lt;/option&gt; &lt;option value="葡萄"&gt;葡萄&lt;/option&gt; &lt;/select&gt; &lt;h2&gt;您选择的水果是: &#123;&#123;fruit&#125;&#125;&lt;/h2&gt; &lt;!--2.选择多个值--&gt; &lt;select name="abc" v-model="mySelects" multiple="multiple"&gt; &lt;option value="苹果"&gt;苹果&lt;/option&gt; &lt;option value="香蕉"&gt;香蕉&lt;/option&gt; &lt;option value="榴莲"&gt;榴莲&lt;/option&gt; &lt;option value="葡萄"&gt;葡萄&lt;/option&gt; &lt;/select&gt; &lt;h2&gt;您选择的水果是：&#123;&#123;fruits&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src="../js/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; const app = new Vue(&#123; el:"#app", data:&#123; message:"您好啊", mySelect:'香蕉', //默认值 mySelects:[] &#125; &#125;)&lt;/script&gt; ==总结== 以上所述的是vue中的v-model的使用和一下小小的详解，希望对大家有所帮助！！！]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加访问量统计]]></title>
    <url>%2F2019%2F05%2F21%2Fhexo%2FHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[前导必备 博主博客地址 博主使用的是next主题 访问量统计使用不蒜子 关于比较早的时候使用next主题，想要开启站点统计功能（访客、总访问量），只需要找到_config.yml配置文件，把busuanzi_count的enable设置为true即可。但是近期，大概是2018年10月份左右，这个不蒜子的统计功能就失效了。查阅了不蒜子官方的说法。 引入不蒜子并添加站点访问量 1、在themes/next/layout/_partial/footer.ejs末尾添加如下代码 12345&lt;div&gt;&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;&lt;span id="busuanzi_container_site_pv"&gt;本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt;&amp;nbsp&amp;nbsp&amp;nbsp&lt;span id="busuanzi_container_site_uv"&gt;本站访客数&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人次&lt;/span&gt;&lt;/div&gt; 2、注意：_config.yml配置文件busuanzi_count是需要打开的。我这里是已经开启过了，只是域名失效了而已。如果默认没有打开，可以参考如下配置。配置文件路径：\themes\next_config.yml1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 访客数 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 阅读数 page_pv_footer: 个人站点]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序 授权登录流程]]></title>
    <url>%2F2018%2F07%2F13%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%20%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言 由于微信官方修改了 getUserInfo 接口，所以现在无法实现一进入微信小程序就弹出授权窗口，只能通过 button 去触发 实现思路 自定义一个微信授权登录页面，让用户通过button去触发getUserInof接口。在用户进入微信小程序时，判断用户是否授权，如果没有授权就显示授权页面，让用户去执行授权操作。如果授权了，则直接跳过，进入首页。 小程序登录流程 第一步 获取当前微信用户的登录凭证（code） 可通过wx.login api获得 wx.login换取的code只能使用一次，如果需要新的code只能重新调用wx.login接口 12345wx.login(&#123; success:(res)=&gt;&#123; let code= res.code &#125;&#125;) 第二步通过wx.login获得临时登录凭证传给服务器获得openID和session_key,服务器需要通过appid和appsecret（这两个是从小程序后台获得）、code（从wx.login中获取到）向微信服务器发送请求获取session_key和openID。确保安全，建议将获得的session_key加密再传给客户端。 第三步客户端获得加密后的登录态后把登录态存在本地以便后面进行业务请求。由于小程序中不存在cookie机制。所以可以把登录态存储在storage中。 源码index.wxml123456789101112131415161718&lt;view wx:if="&#123;&#123;isHide&#125;&#125;"&gt; &lt;view wx:if="&#123;&#123;canIUse&#125;&#125;" &gt; &lt;view class='header'&gt; &lt;image src='/images/wx_login.png'&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class='content'&gt; &lt;view&gt;申请获取以下权限&lt;/view&gt; &lt;text&gt;获得你的公开信息(昵称，头像等)&lt;/text&gt; &lt;/view&gt; &lt;button class='bottom' type='primary' open-type="getUserInfo" lang="zh_CN" bindgetuserinfo="bindGetUserInfo"&gt; 授权登录 &lt;/button&gt; &lt;/view&gt; &lt;view wx:else&gt;请升级微信版本&lt;/view&gt;&lt;/view&gt;&lt;view wx:else&gt; &lt;view&gt;首页内容&lt;/view&gt;&lt;/view&gt; index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Page(&#123; data: &#123; //判断小程序的API，回调，参数，组件等是否在当前版本可用。 canIUse: wx.canIUse('button.open-type.getUserInfo'), isHide: false &#125;, onLoad: function() &#123; var that = this; // 查看是否授权 wx.getSetting(&#123; success: function(res) &#123; if (res.authSetting['scope.userInfo']) &#123; wx.getUserInfo(&#123; success: function(res) &#123; // 用户已经授权过,不需要显示授权页面,所以不需要改变 isHide 的值 // 根据自己的需求有其他操作再补充 // 我这里实现的是在用户授权成功后，调用微信的 wx.login 接口，从而获取code wx.login(&#123; success: res =&gt; &#123; // 获取到用户的 code 之后：res.code console.log("用户的code:" + res.code); // 可以传给后台，再经过解析获取用户的 openid // 或者可以直接使用微信的提供的接口直接获取 openid ，方法如下： // wx.request(&#123; // // 自行补上自己的 APPID 和 SECRET // url: 'https://api.weixin.qq.com/sns/jscode2session?appid=自己的APPID&amp;secret=自己的SECRET&amp;js_code=' + res.code + '&amp;grant_type=authorization_code', // success: res =&gt; &#123; // // 获取到用户的 openid // console.log("用户的openid:" + res.data.openid); // &#125; // &#125;); &#125; &#125;); &#125; &#125;); &#125; else &#123; // 用户没有授权 // 改变 isHide 的值，显示授权页面 that.setData(&#123; isHide: true &#125;); &#125; &#125; &#125;); &#125;, bindGetUserInfo: function(e) &#123; if (e.detail.userInfo) &#123; //用户按了允许授权按钮 var that = this; // 获取到用户的信息了，打印到控制台上看下 console.log("用户的信息如下："); console.log(e.detail.userInfo); //授权成功后,通过改变 isHide 的值，让实现页面显示出来，把授权页面隐藏起来 that.setData(&#123; isHide: false &#125;); &#125; else &#123; //用户按了拒绝按钮 wx.showModal(&#123; title: '警告', content: '您点击了拒绝授权，将无法进入小程序，请授权之后再进入!!!', showCancel: false, confirmText: '返回授权', success: function(res) &#123; // 用户没有授权成功，不需要改变 isHide 的值 if (res.confirm) &#123; console.log('用户点击了“返回授权”'); &#125; &#125; &#125;); &#125; &#125;&#125;) 以上就是我的一些理解。有逻辑不清晰的地方,请不吝留言赐教!]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用代码]]></title>
    <url>%2F2018%2F04%2F10%2Fgit%2Fgit%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[创建版本库1$git init 添加到暂存区1$git add &lt;file&gt; 提交到仓库1$git commit -m "your description" -m 后面是解析说明 查看仓库当前状态 1$git status 查看距离上次提交做了哪些修改1$git diff &lt;file&gt; 查看提交记录1$git log 精简格式 1$git log --pretty=online 查看每一次提交记录，包括版本回退记录 1$git reflog 版本回退 通过HEAD回退版本 1$git reset --hard HEAD^ HEAD 表示当前版本HEAD^表示上1个版本 HEAD^ 表示上2个版本 HEAD~n 表示上n个版本 通过commit id回退版本 1$git reset --hard 3628164 删除文件1$git rm &lt;file&gt; 恢复误删文件1$git checkout -- &lt;file&gt; 添加远程库1git remote add origin git@github.com:luosijie/Front-end-Blog.git 或 1$git remote add origin https://github.com/luosijie/Front-endBlog.git 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https 查看远程库1$git remote 删除远程库1git remote remove &lt;name&gt; 推送内容到远程库12//origin 为远程库名称$ git push -u origin master 第一次推送master分支时，由于远程库是空的，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 第二次开始就可以用 1$ git push origin master 来源 廖雪峰Git教程]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax入门和发送http请求]]></title>
    <url>%2F2017%2F07%2F21%2FAjax%2FAjax%E5%85%A5%E9%97%A8%E5%92%8C%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[同步和异步同步和异步的概念 同步：必须等待前面的任务完成，才能继续后面的任务。 异步：不受当前任务的影响 拿排队举例 同步：在银行排队时，只有等到你了，才能够去处理业务。 异步：在排队的时候，可以玩手机。 异步更新网站在访问一个普通的网站时，当浏览器加载完HTML、CSS、JS以后，网站的内容就固定了。如果想让网站内容发生更改，就必须刷新页面才能够看到更新的内容。 如果用到异步更新，情况就大为改观了。比如，我们在访问新浪微博时，看到一大半了，点击底部的加载更多，会自动帮我们加载更多的微博，同时页面并没有刷新。 AjaxAjax的概念Ajax：Asynchronous Javascript And XML（异步 JavaScript 和XML）。它并不是凭空出现的新技术，而是对于现有技术的结合。Ajax的核心是 js 对象：XMLHttpRequest。 发送Ajax请求的五个步骤 就是使用XMLHttpRequest对象的五个步骤。 一个完整的HTTP请求需要的是: 请求的网址、请求方法get/post。 提交请求的内容数据，请求主体等。 接收响应回来的内容。 发送Ajax请求的五个步骤：（1）创建异步对象。即XMLHttpRequest对象。（2）使用open方法设置请求的参数。open(method,url,async).参数解析：请求的方法、请求的url、是否异步。（3）发送请求。（4）注册事件。注册onreadystatechange事件，状态改变时就会调用。如果要在数据完整请求回来的时候才会调用，需要手动写一些判断的逻辑。（5）获取返回的数据。 Ajax请求：以get请求举例(1) index.html1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Ajax 发送 get 请求&lt;/h1&gt;&lt;input type="button" value="发送get_ajax请求" id='btnAjax'&gt;&lt;script type="text/javascript"&gt; // 绑定点击事件 document.querySelector('#btnAjax').onclick = function () &#123; // 发送ajax 请求 需要 五步 // （1）创建异步对象 var xhr = new XMLHttpRequest(); // （2）设置请求的参数。包括：请求的方法、请求的url。 xhr.open('get', '02-ajax.php'); // （3）发送请求 xhr.send(); //（4）注册事件。 onreadystatechange事件，状态改变时就会调用。 //如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。 xhr.onreadystatechange = function () &#123; // 为了保证 数据 完整返回，我们一般会判断 两个值 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的 // 5.在注册的事件中 获取 返回的 内容 并修改页面的显示 console.log('数据返回成功'); // 数据是保存在 异步对象的 属性中 console.log(xhr.responseText); // 修改页面的显示 document.querySelector('h1').innerHTML = xhr.responseText; &#125; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; (2)01-ajax.php123&lt;?php echo 'hello'; ?&gt; 实现效果如下: Ajax请求：以post请求举例(1) index.html123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Ajax 发送 post 请求&lt;/h1&gt;&lt;input type="button" value="发送put_ajax请求" id='btnAjax'&gt;&lt;script type="text/javascript"&gt; // 异步对象 var xhr = new XMLHttpRequest(); // 设置属性 xhr.open('post', '02.post.php'); // 如果想要使用post提交数据,必须添加此行 xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); // 将数据通过send方法传递 xhr.send('name=fox&amp;age=18'); // 发送并接受返回值 xhr.onreadystatechange = function () &#123; // 这步为判断服务器是否正确响应 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125; &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; XMLHttpRequest 对象详解 使用 XMLHttpRequest 对象的五个步骤。 发送请求发送请求的方法:1open(method, url, async); 参数解析： method：请求的类型; GET或POST url：文件在服务器上的位置 async：true（异步）或者false（同步） 另外还有一个方法：（仅限于POST请求）1send(string); POST请求时注意如果想让 像form 表单提交数据那样使用POST请求，就需要使用XMLHttpRequest 对象的 setRequestHeader()方法 来添加 HTTP 头。然后在 send() 方法中添加想要发送的数据：12345xmlhttp.open("POST","ajax_test.php", true);xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");xmlhttp.send("name=hello&amp;age=25"); #### onreadystatechange 事件 注册 onreadystatechange 事件后，每当 readyState 属性改变时，就会调用 onreadystatechange 函数。 readyState：（存有 XMLHttpRequest 的状态。从0 到 4 发生变化） 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪status： 200: “请求成功” 404: 未找到页面。在 onreadystatechange 事件中，当 readyState 等于4，且状态码为200时，表示响应已就绪。 服务器响应的内容 responseText：获得字符串形式的响应数据。 responseXML：获得 XML 形式的响应数据。 如果响应的是普通字符串，就使用responseText；如果响应的是XML，使用responseXML Ajax 传输 JSONJSON 的语法JSON(JavaScript ObjectNotation)：是ECMAScript的子集。作用是进行数据的交换。语法更为简洁，网络传输、机器解析都更为迅速。 语法规则： 数据在键值对中 数据由逗号分隔 花括号保存对象 方括号保存数组 数据类型： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null 示例：123456789101112131415161718//数组[ &#123; "name":"小明", "age":"25" &#125;, &#123; "name":"小红", "age":"24" &#125;]//对象&#123; "name":"小明", "age":"25", "sex":"男"&#125; json 字符串 &lt;–&gt; js 对象基本上，所有的语言都有将 json 字符串转化为该语言对象的语法。比如在 js中： JSON.parse()：将JSON字符串转化为 js 对象。例如： 12// 将 JSON 字符串格式化为 js 对象var jsObj = JSON.parse(ajax.responseText); JSON.stringify()：将 JS 对象转化为JSON字符串。例如： 12345678910 var Obj = &#123; name: "小明", age: 25, sex: "男"&#125;;console.log(Obj);// 将 js 对象格式化为 JSON 字符串var jsonStr = JSON.stringify(Obj); 下面就是以PHP为例将 json 字符串 &lt;–&gt; js 对象 json_decode()方法：将json字符串转化为变量。 json_encode()方法：将变量转化为json字符串。举例： 1234567891011121314 &lt;?php header("Content-Type:text/html;charset=utf-8"); // json字符串 $jsonStr = '&#123;"name":"小明","age":25,"sex":"男"&#125;'; // 字符串转化为 php对象 print_r(json_decode($jsonStr)); echo "&lt;br&gt;"; // php数组 $arrayName = array('name' =&gt;'littleFox' ,'age' =&gt; 13 ); // php对象 转化为 json字符串 print_r(json_encode($arrayName));?&gt; 输出结果： 12 stdClass Object ( [name] =&gt; itcast [age] =&gt; 25 [skill] =&gt; 男 )&#123;"name":"小红","age":24&#125; ajax请求解析json例子(1) data.json12345&#123; "name":"小明", "age":"25", "sex":"男"&#125; (2)json.php123456&lt;?php // 读取json文件 并返回即可 echo file_get_contents('info/Person.json'); ?&gt; (3)getjons.html1234567891011121314151617181920212223242526272829303132333435363738 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;获取 json 数据&lt;/h1&gt; &lt;input type="button" value="获取json" id='btnJson'&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type="text/javascript"&gt; // 获取的是一个 如果要获取多个 // document.querySelectorAll(selector) document.querySelector("#btnJson").onclick = function () &#123; var xhr = new XMLHttpRequest(); xhr.open('get','json.php'); xhr.send(); xhr.onreadystatechange = function () &#123; if (xhr.readyState==4&amp;&amp;xhr.status==200) &#123; // json 字符串 是字符串 所以我们可以 通过 responseText获取 console.log(xhr.responseText); // 转化为 js对象 var jsObj = JSON.parse(xhr.responseText); console.log(jsObj); // 拼接ul s var str = ''; str+='&lt;ul&gt;'; str+='&lt;li&gt;'+jsObj.name+'&lt;/li&gt;'; str+='&lt;li&gt;'+jsObj.skill+'&lt;/li&gt;'; str+='&lt;li&gt;'+jsObj.friend+'&lt;/li&gt;'; str+='&lt;/ul&gt;'; // 设置到界面上 document.body.innerHTML = str; &#125; &#125; &#125;&lt;/script&gt; 演示效果： jQuery 中的 AjaxJQuery作为最受欢迎的js框架之一，常见的Ajax已经帮助我们封装好了，只需要调用即可。更为详细的api文档可以查阅 w3cSchool_JQueryAjax 格式：12345678$.ajax(&#123; url:'01.php',//请求地址 data:'name=小明&amp;age=25',//发送的数据 type:'GET',//请求的方式 success:function (argument) &#123;&#125;,// 请求成功执行的方法 beforeSend:function (argument) &#123;&#125;,// 在发送请求之前调用,可以做一些验证之类的处理 error:function (argument) &#123;console.log(argument);&#125;,//请求失败调用 &#125;) 更多关于jquery-ajax的文章jQuery.ajax()]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源和跨域]]></title>
    <url>%2F2017%2F07%2F11%2FAjax%2F%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[前言众所周知浏览器的同源策略及跨域的方法在前端面试中也是出场率极高的问题，本文主要跟大家分享了关于前端面试时会遇到的同源和跨域问题，下面话不多说了，来一起看看详细的介绍吧。 什么是同源策略同源同源策略是浏览器的一种安全策略，所谓同源是指，域名，协议，端口完全相同。 跨域问题的解决方案 JSONP:script 标签的 src 属性传递数据。 iframe 元素会创建包含另外一个文档的内联框架（即行内框架） 代理：如vue-cli项目中的config/index.js文件中的proxyTable设置所要跨域访问的地址 JSONPJSONP(JSON with Padding)：带补丁的 json，本质是利用了 &lt;script src=&quot;&quot;&gt;&lt;/script&gt;标签具有可跨域的特性，由服务端返回一个预先定义好的JS函数的调用，并且将服务器数据以该函数参数的形式传递过来。此方法需要前后端配合完成。html标签的 src 属性是支持跨域的：1&lt;img src="http://www.lolint.com/images/avatar.jpg" alt=""&gt; jsonp 就是利用这个特性实现的跨域，但用的是 script 标签。如下：123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- `jsonp` 就是 利用`src`，实现的跨域 用的是 `script`标签 --&gt;&lt;script type="text/javascript" src='http://192.168.141.137/2018-02-28/myData.php'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上方那一行的代码，意思是：刷新A服务器上的index页面后，会去请求 B 服务器上的 myData.php 这个页面。而且请求的方式是 get 请求。但是 B 服务器上的页面不是你想请求就可以请求的，大家一起配合才可以。具体实现步骤：需要首先声明的是，jsonp 只能通过 GET 方式进行请求。（1）A客户端的代码：123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type="text/javascript"&gt; // 定义 eatFood()方法 function fn(data) &#123; console.log('我被调用了哦'); console.log(data); &#125;&lt;/script&gt;&lt;!-- 使用 `script`标签 发送了 `get`请求 去到了一个 `php`页面 --&gt;&lt;script type="text/javascript" src='http://192.168.141.137/01.php?callback1=fn'&gt;&lt;/script&gt; 我们来分析上方代码中的最后一行的那个url：A客户端请求的是 B服务器上的 01.php页面。url里有个callback1=fn，意思是：callback1是A和B 之间的约定，约定后，将执行方法 fn。 其实，fn方法已经在最后一行代码中执行了。只不过，fn方法里的data数据，是从 B 服务器中获取的。（2）B服务器端的代码：1234567&lt;?php $mycallBack = $_GET['callback1']; $arr = array("zhangsan","lisi","zhaoliu"); echo $mycallBack.`(`.json_encode($arr).`)`; //字符串拼接?&gt; 代码解释：第一行的callback1 是A和B之间的约定，二者必须一致。 echo语句中输出的内容，即使要返回给A客户端的内容，此内容会保存在 A客户端的fn方法的data里。 data[0]指的是 zhangsan。json_encode指的是，将php对象转化为 json。刷新A页面，输出结果为：1mycallBack(["zhangsan","lisi","zhaoliu"]) 配置proxyTable解决跨域问题 我们使用vue-cli生成的项目目录里，config下面的index.js有个proxyTable属性 然后我们做如下设置123456789proxyTable: &#123; // 这里可以理解为使用"/api" 代替 "target" 里的地址， // 比如说我们要调用的地址是 http://www.example.com/api/list, 则写成 /api/list 就可以了 '/api': &#123; target: 'http://www.example.com', // 你请求的api地址 secure: false, // 如果是https接口，需要配置这个参数 changeOrigin: true //这个参数是用来回避跨站问题的，配置完之后发请求时会自动修改http header里面的host &#125; &#125;, 注意以上配置只在开发环境起作用webpack-dev-server更加详细的配置: https://webpack.js.org/configuration/dev-server/#devserver-proxy 那么为什么我们设置这个proxyTable可以帮我们解决跨域问题呢？ 其实vue-cli里的这个设置来自于其集成的插件 http-proxy-middleware github: https://github.com/chimurai/http-proxy-middleware 这个插件可以帮我们在本地虚拟一个服务器接收请求并代替你发送该请求，因为是在服务端替我们发请求所以就没有我们烦恼的跨域问题了，当然这只适用于开发环境。 项目上线怎么办？ 我们通过配置proxyTable解决了本地开发环境请求接口跨域的问题，但是我们项目上线还是要替换成线上的接口地址的。如果我们的前端项目合后端服务不在同一个域名下，我们可以使用目前比较流行的 CORS 来处理跨域。这里就不展开讲了。 我们可以利用webpack配置的环境变量来实现开发环境和打包后的api区分假设我们使用axios进行请求发送 我们可以做如下配置123456789101112131415import axios from 'axios';const config = &#123; timeout: 60000， withCredentials: true // 访问线上api时axios发送跨域请求时需要设置这个参数&#125;if(process.env.NODE_ENV === 'development') &#123; // 开发环境&#125; else if(process.env.NODE_ENV === 'production') &#123; // 生产环境 config.baseURL = "http://www.baidu.com"; //这里是线上api请求地址&#125;const server = axios.create(config); 这样配置后我们开发环境中就可以使用proxyTable代理请求，项目打包后请求地址就会被替换成线上的api地址。假设我们开发环境请求的api地址为 http://www.example.com/api/list线上环境请求的api地址为 http://www.baidu.com/api/list那么我们发请求的时候只需要这么写123server.get("/api/list").then(res =&gt; &#123; ...&#125;) 项目打包后，webpack就可以自动帮我们把请求地址替换成线上的地址了。]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序通过api接口将json数据展现到小程序示例]]></title>
    <url>%2F2017%2F07%2F10%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%9A%E8%BF%87api%E6%8E%A5%E5%8F%A3%E5%B0%86json%E6%95%B0%E6%8D%AE%E5%B1%95%E7%8E%B0%E5%88%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[用到的知识 wx.request 请求接口资源(微信小程序api的发起请求部分) swiper实现轮播图的组件 wx:for 循环语句 微信小程序的基础知识 实现原理首先看一下这个请求函数12345678910111213141516171819202122wx.request(&#123; //请求地址 url:"https://locally.uieee.com/xxx", //请求的参数 data：&#123;&#125;, //设置请求的header header:&#123;&#125;, //请求方式 method:"GET", //数据类型 dataType:'json', //成功请求执行的回调函数 success:function(res)&#123; console.log(res); &#125;, //请求失败执行的回调函数 fail:function(res)&#123; console.log(res); &#125;, //接口调用结束的回调函数 (调用成功、失败都会执行) complete:function(res)&#123;&#125;,&#125;) 1.接口数据接口数据的json格式的开头12345"state":"0","stories":[&#123;id: 1, image: "http://ww1.sinaimg.cn/mw690/006ThXL5ly1fj7zx3w751j30u00dmgy3.jpg"&#125;,&#123;id: 2, image: "http://ww1.sinaimg.cn/mw690/006ThXL5ly1fj6ckx9tlwj30u00fqk8n.jpg"&#125;] 2. index.js在index.js里获取数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// pages/profile/profile.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; duration: 2000, indicatorDots: true, autoplay: true, interval: 3000, loading: false, plain: false, sliderList:[] &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; var _this = this; //不要漏了这句，很重要滴！！！ wx.request(&#123; url:"https://locally.uieee.com/xxx", headers: &#123; 'Content-Type': 'application/json' &#125;, success:function(res)&#123; /** * this.setData 有两个功能： * 1. 更新数据 * 2. 更新视图 */ //将获取到的json数据，存在名字叫sliderList的这个数组中 _this.setData(&#123; sliderList:res.data &#125;) &#125; &#125;) &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123;&#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123;&#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123;&#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123;&#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123;&#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123;&#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123;&#125;&#125;) index.wxml在index.wxml中渲染1234567&lt;view class='slider'&gt; &lt;swiper indicator-dots="&#123;&#123;indicatorDots&#125;&#125;"autoplay="&#123;&#123;autoplay&#125;&#125;" class="banners" interval="&#123;&#123;interval&#125;&#125;" duration="&#123;&#123;duration&#125;&#125;"&gt; &lt;swiper-item wx:for="&#123;&#123; sliderList &#125;&#125;" wx:key="id" &gt; &lt;image src="&#123;&#123; item.image &#125;&#125;" width="375" height="150" mode="aspectFill" lazy-load /&gt; &lt;/swiper-item&gt; &lt;/swiper&gt;&lt;/view&gt;]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局学习和总结]]></title>
    <url>%2F2017%2F06%2F11%2Fflex%2Fflex-conclusion%2F</url>
    <content type="text"><![CDATA[前言很长一段时间, 我知道有flex这个布局方式, 但是始终没有去学它. 最近由于学习小程序，发现里面需要使用flex布局, 于是决定学习一下. 在拜读了阮一峰的flex布局教程和HaoyCn有关flex属性的回答后整理成此文章，以便加深印象。 什么是flexFlexbox Layout，官方名为 CSS Flexible Box Layout Module, 意为”弹性布局”，是CSS3中引入的一种更加灵活高效的布局/对齐/排序方式(还有一种更适合大型布局的网格布局CSS Grid Layout Module). flex是flexible的缩写. 任何一个容器都可以指定为flex布局。 123.box &#123; display: flex;&#125; 行内元素也可以使用flex布局。 123.box &#123; display: inline-flex;&#125; flex的基本概念 1、采用flex布局的元素被称为flex容器（flex container），他的子元素即为flex元素（flex item）。2、flex容器中包含两个相互垂直的轴，即主轴（main axis）和副轴（cross axis)。3、flex元素沿主轴从主轴起点 (main start)到主轴终点 (main end)依次排布。4、如果flex容器包含多行flex元素，则flex行（flex lines）沿副轴从副轴起点（cross start）到副轴终点（cross end)依次排布。5、单个flex元素占据的主轴空间叫做主轴程度（main size），占据的副轴空间叫做副轴长度（cross size）。 flex的兼容性 flex属性用于flex容器的属性以下6个属性设置在容器上 属性 含义 flex-direction 主轴方向 flex-wrap 换行样式 flex-flow 前两个的简写形式 justify-content 主轴对齐方式 align-items 单行的副轴对齐方式 align-content 多行的副轴对齐方式 注意：flex容器的column-*属性会失效。flex容器无法拥有::first-line和 ::first-letter虚元素。 flex-direction属性flex-direction 属性决定主轴方向(即项目的排序方向)。 含义 主轴方向 可选值 row 、row-reverse 、 column 、 column-reverse 默认值 row row 主轴为水平方向，七点在左端。 row-reverse 主轴为水平方向，起点在右端。 column 主轴为垂直方向，起点在上沿。 column-reverse 主轴为垂直方向，起点在下沿。 123.box&#123; flex-direction: row | row-reverse | column | column-reverse;&#125; flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 flex-flow属性flex-flow属相是flex-direction属性和flex-wrap属性的简写形式，默认值为 row nowrap。123.box&#123; flex-flow:&lt;flex-direction&gt;||&lt;flex-wrap&gt;;&#125; justify-content属性它可能取5个值，具体对齐方式与轴的方向有关，下面假设主轴为从左到右。 值 主轴方向 flex-start 默认值：左对齐 flex-end 右对齐 center 居中 space-between 两端对齐，项目之间的间隔都相等。 space-around 每个项目两侧的间隔相等。所以，项目之间比项目与边框的间隔大一倍。 123.box&#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; align-items属性align-items属性定义项目在交叉轴上如何对齐。它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 值 主轴方向 flex-start 交叉轴的起点对齐。 flex-end 交叉轴的终点对齐。 center 交叉轴的中点对齐。 baseline 项目的第一行文字的基线对齐。 stretch （默认值）:如果项目未设置高度或设为auto，将占满整个容器的高度。 123.box&#123; align-items: flex-start | flex-end | center | baseline | stretch; &#125; align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。该属性可能取6个值。 值 主轴方向 flex-start 与交叉轴的起点对齐。 flex-end 与交叉轴的终点对齐。 center 与交叉轴的中点对齐。 space-between 与交叉轴两端对齐。轴线之间的间隔平均分布。 space-around 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch （默认值）：轴线占满整个交叉轴。 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 用于flex元素的属性这类属性有6种，分别为: 属性 含义 order 排列顺序。 align-self flex元素的副轴对齐方式，对应与flex容器的align-items。 flex-grow 放大比例。 flex-shrink 缩小比例。 flex-basis 初始大小。 flex （上面三个的简写形式。） 注意：flex元素的 float，clear和vertical-align会失效。 order属性order属性定义项目的排序顺序。数值越小，排列越靠前，默认为0. 123.box&#123; order:&lt;integer&gt;;&#125; align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.box&#123; align-self:&#123; auto | flex-start | flex-end | center | baseline | stretch &#125;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 123.box&#123; flex-grow:&lt;number&gt;; /*default 0*/&#125; flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，盖项目将缩小。flex-shrink为 0 则表示，即使flex容器空间不足，该flex元素也不缩小。 123.box&#123; flex-shrink:&lt;number&gt;; /* default 1 */&#125; flex-basis属性 含义 初始大小 可选值 auto、(非负值)。 默认值 auto。 123.box &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; flex-basis定义了分配剩余空间之前flex元素的初始大小，可为长度值（如 20%，5rem等）或 auto等关键词。flex-basis: auto表示, 以flex元素的主轴长度为flex-basis. 若flex元素的主轴长度也是auto, 则以flex元素内容(即所有子元素)的大小为flex-basis。 flex属性 含义 flex-grow, flex-shrink和flex-basis的简写形式 可选值 none [ &lt;‘flex-grow’&gt; &lt;‘flex-shrink’&gt;?、&lt;‘flex-basis’&gt; ] 默认值 0 1 auto ||用来分割两个或多个选项, 从中选取一个或多个, 不限次序. |用来分割两个或多个选项, 从中选取一个. []只是用来分组的. ?代表可选. 举例来说, a | [ b || c ]包含的可能情况有a, b, c, b c, c b.现在回过头来再看none | [ &lt;‘flex-grow’&gt; &lt;‘flex-shrink’&gt;? || &lt;‘flex-basis’&gt; ]就清晰多了.注意, none是一个特殊值, 相当于0 0 auto.另外, 如果flex中不指定: flex-grow成员, 则flex-grow会被置为1. flex-shrink成员, 则flex-shrink会被置为1. flex-basis成员, 则flex-basis会被置为0.注意: flex的初始值是0 1 auto, 即由每个flex因子本身的默认值组成(比方说flex-grow的默认值就是0).]]></content>
      <categories>
        <category>Flex</category>
      </categories>
      <tags>
        <tag>Flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS常见的几种布局]]></title>
    <url>%2F2017%2F05%2F11%2Fcss%2FCSS-layout%2F</url>
    <content type="text"><![CDATA[单列布局常见的单列布局有两种方法： header，content，footer等宽的单列布局 header与footer等宽，content 略窄的单列布局 第一种 代码如下 index.html123&lt;div class="header"&gt;&lt;/div&gt;&lt;div class="content"&gt;&lt;/div&gt;&lt;div class="footer"&gt;&lt;/div&gt; style.css12345678910111213141516171819.header&#123; margin:0 auto; max-width: 960px; height:100px; background-color: blue;&#125;.content&#123; margin: 0 auto; max-width: 960px; height: 400px; background-color: aquamarine;&#125;.footer&#123; margin: 0 auto; max-width: 960px; height: 100px; background-color: aqua;&#125; 第二种 代码如下index.html123456&lt;div class="header"&gt; &lt;div class="nav"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="content"&gt;&lt;/div&gt;&lt;div class="footer"&gt;&lt;/div&gt; style.css12345678910111213141516171819202122232425.header&#123; margin:0 auto; max-width: 960px; height:100px; background-color: blue;&#125;.nav&#123; margin: 0 auto; max-width: 800px; background-color: darkgray; height: 50px;&#125;.content&#123; margin: 0 auto; max-width: 800px; height: 400px; background-color: aquamarine;&#125;.footer&#123; margin: 0 auto; max-width: 960px; height: 100px; background-color: aqua;&#125; 两列自适应布局两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式 float+overflow:hidden如果是普通的两列布局，浮动+普通元素的margin便可以实现，但如果是自适应的两列布局，利用float+overflow:hidden便可以实现，这种办法主要通过overflow触发BFC,而BFC不会重叠浮动元素。由于设置overflow:hidden并不会触发IE6-浏览器的haslayout属性，所以需要设置zoom:1来兼容IE6-浏览器。具体代码如下： index.html12345678910&lt;div class="parent"&gt; &lt;div class="left"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; style.css12345678910111213141516.parent &#123; overflow: hidden; zoom: 1; background-color: lightgrey;&#125;.left &#123; float: left; margin-right: 20px; background-color: lightblue;&#125;.right &#123; overflow: hidden; zoom: 1; background-color: lightgreen;&#125; 注意点:如果侧边栏在右边时，注意渲染顺序。即在HTML中，先写侧边栏后写主内容 Flex布局Flex布局，也叫弹性盒子布局 index.html12345678910&lt;div class="parent"&gt; &lt;div class="left"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; style.css123456789101112.parent &#123; display:flex;&#125;.left &#123; background-color: lightblue;&#125;.right &#123; margin-left:20px; flex:1; background-color: lightgreen;&#125; Grid布局Grid布局，是一个基于网格的二维布局系统，目的是用来优化用户界面设计。 index.html123456789&lt;div class="parent"&gt; &lt;div class="left"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; style.css12345.parent &#123; display:grid; grid-template-columns:auto 1fr; grid-gap:20px&#125; 三栏布局特征：中间列自适应宽度，旁边两侧固定宽度，实现三栏布局有多种方式（可以猛戳实现三栏布局的几种方法),本文着重介绍圣杯布局和双飞翼布局。 圣杯布局 特点 比较特殊的三栏布局，同样也是两边固定宽度，中间自适应，唯一区别是dom结构必须是先写中间列部分，这样实现中间列可以优先加载。 index.html12345&lt;div class="container"&gt; &lt;div class="main"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt; style.css1234567891011121314151617181920212223242526272829.container &#123; margin-left: 120px; margin-right: 220px;&#125;.main &#123; float: left; width: 100%; height:300px; background: green;&#125;.left &#123; position: relative; left: -120px; float: left; height: 300px; width: 100px; margin-left: -100%; background: red;&#125;.right &#123; position: relative; right: -220px; float: right; height: 300px; width: 200px; margin-left: -200px; background: blue;&#125; 缺点 center部分的最小宽度不能小于left部分的宽度，否则会left部分掉到下一行 如果其中一列内容高度拉长(如下图)，其他两列的背景并不会自动填充。(借助伪等高布局可解决) 伪等高布局 如下：1234567891011.main,.left,.right &#123; padding-bottom: 10000px; margin-bottom: -10000px;&#125;.container &#123; padding-left: 220px; padding-right: 220px; overflow: hidden;//把溢出背景切掉&#125; 双飞翼布局 特点 同样也是三栏布局，在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题。 缺点 多加一层 dom 树节点，增加渲染树生成的计算量。 index.html123456&lt;div class="content"&gt; &lt;div class="main"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="left"&gt;&lt;/div&gt;&lt;div class="right"&gt;&lt;/div&gt; style.css123456789101112131415161718192021222324252627282930313233.content &#123; float: left; width: 100%;&#125;.main &#123; height: 200px; margin-left: 110px; margin-right: 220px; background: green;&#125;.main::after &#123; content: ''; display: block; font-size:0; height: 0; zoom: 1; clear: both;&#125;.left &#123; float:left; height: 200px; width: 100px; margin-left: -100%; background: red;&#125;.right &#123; float: right; height: 200px; width: 200px; margin-left: -200px; background: blue;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【读书】《锋利的jQuery》]]></title>
    <url>%2F2017%2F03%2F10%2Fjquery%2Fsharp-jquery%2F</url>
    <content type="text"><![CDATA[通过对《锋利的jQuery》（第二版）一书的学习，发现此书讲解通俗易懂，是学习jQuery的一本很好的指导书，特作如下总结。此书主要讲解了jQuery的常用操作，包括认识jQuery，jQuery选择器，jQuery中的DOM操作，jQuery中的事件和动画，jQuery对表单、表格的操作及更多应用，jQuery与Ajax的应用等。 jQuery的优势jQuery强调的理念是写得少，做的多。jQuery独特的选择器、链式操作、事件处理机制和封装完善的Ajax都是其他JavaScript库望尘莫及的。概括起来，jQuery有以下优势。 轻量级 强大的选择器 出色的DOM操作 可靠的事件处理机制 完善的Ajax 不污染顶级变量 出色的浏览器兼容性，支持IE6.0+、Firefox3.6+、Safari5.0+、Opera、Chrome 链式操作方式 隐式迭代 行为层与结构层的分离 丰富的插件支持 完善的文档 开源 jQuery代码的编写在jQuery库中，$就是jQuery的一个简写形式，例如$(&quot;#foo&quot;)和jQuery(&quot;#foo&quot;)是等价的。规范：1、对于同一个对象不超过3个操作的，可以直接写在一行2、对于同一个对象的较多操作，建议每行写一个操作3、对于多个对象的少量操作，可以每个对象写一行，涉及子元素的，可以考虑缩进建议：jQuery对象使用$开头，例：var $variable = jQuery对象，var variable= DOM对象 window.onload 和 $(document).ready() 对比 - window.onload $(document).ready() 执行时间 必须等待网页中所有的内容加载完毕（）包括图片才执行 只需要 DOM 加载完就执行（不包括图片等） 编写个数 不能同时编写多个 能同时编写多个 简化写法 无 $(document).ready(function(){}) 可以简写成 $(function(){}) jQuery 的链式操作风格用过jQuery的朋友都知道他强大的链式操作，方便，简洁，易于理解， 如下:1$(this).addClass("current").next().show().parent().siblings().children("a").removeClass("current").next().hide(); 为了进一步改善代码的可读性和可维护性可将代码改为如下格式：1234$(this).addClass("current") // 给当前元素添加 "current" 样式 .next().show() // 下一个元素显示 .parent().siblings().children("a").removeClass("current") // 父元素的同辈元素的子元素 &lt;a&gt; 移除 "current" 样式.next().hide(); //他们的下一个元素隐藏 jQuery 对象和 DOM 对象DOM对象就是DOM树中的节点。可以通过JavaScript中的getElementsByTagName或者getElementById来获取元素节点。 jQuery对象就是通过jQuery包装DOM对象后产生的对象。 在jQuery对象中违法使用DOM对象的任何方法。同样，DOM对象也不能使用jQuery里的方法。 所以我们要区分什么是JavaScript原生方法，什么是jQuery方法。 以下是都是错误的方法：123$("#id").innerHTML;$("#id").checked;document.getElementById("id").html(); jQuery对象和DOM对象的相互转换在讨论jQuery对象和DOM对象的相互转换之前，先约定好定义变量的风格，如果获取的对象时jQuery对象，那么在变量前面加上$符号。 jQuery 对象转化为 DOM 对象jQuery对象不能使用DOM中的方法，jQuery提供了两种方法将一个jQuery对象转换DOM对象，即[index]和get（index）。 （1）jQuery对象是一个类似数组的对象，可以通过[index]得到相应DOM对象。 123var $cr = $("#cr"); //jQuery对象var cr = $cr[0]; //将jQuery对象转为DOM对象console.log(cr); //查看是否转换成功 （2）通过get(index)得到。123var $cr = $("#cr"); //jQuery对象var cr = $cr.get(0); //DOM对象console.log(cr); //查看是否转换成功 DOM 对象转化为 jQuery 对象只需要使用$()将DOM对象包装起来即可得到jQuery对象。 12var cr = document.getElementById("cr"); //DOM对象var $cr = $(cr); //将DOM对象转换jQuery对象 注：DOM对象只能使用DOM方法，jQuery对象只能使用jQuery的方法。 解决 jQuery 和其他库的冲突在 jQuery 库中，几乎所有的插件都被限制在它的命名空间里。通常，全局对象都被很好地储存在 jQuery 的命名空间里。因此和其他库一起使用时，不会引起冲突。注：默认情况下，jQuery用$作为自身的快捷方式。 1、jQuery库在其他库之后导入 （1）在其他库和jQuery库加载完毕之后，可以在任何时候调用jQuery.noConflict()函数将变量$的控制权移交其他的JavaScript库。例：12345678910111213&lt;!-- 引入prototype库 --&gt;&lt;script type="text/javascript" src="lib/prototype.js"&gt;&lt;/script&gt;&lt;!-- 引入jQuery库 --&gt;&lt;script type="text/javascript" src="lib/jQuery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; jQuery.noConflict(); //将变量$的控制权移交给prototype.js jQuery(function()&#123; //使用jQuery jQuery("p").click(function()&#123; alert(jQuery(this).text()); &#125;); &#125;); $('pp').style.display = 'none'; //使用prototype.js隐藏元素&lt;/script&gt; （2）想确保jQuery不与其他库冲突，又想自定义快捷方式：例：123456789&lt;script type="text/javascript"&gt; var $j = jQuery.noConflict(); //自定义快捷方式 $j(function()&#123; //使用jQuery，利用自定义快捷方式 $j $j("p").click(function()&#123; alert.($j(this).text()); &#125;); &#125;); $('pp').style.display = 'none'; //使用prototype.js隐藏元素&lt;/script&gt; （3）如果你还想继续使用 $ 而不管其他函数的 $() 方法，同时又不想与其他库冲突，那么你可以其一、123456789&lt;script type="text/javascript"&gt; jQuery.noConflict(); //将变量$的控制权移交给prototype.js jQuery(function($)&#123; //使用jQuery设定页面加载时执行的函数 $("p").click(function()&#123; //函数内部继续使用$() alert.($(this).text()); &#125;); &#125;); $('pp').style.display = 'none'; //使用prototype.js隐藏元素&lt;/script&gt; 其二、1234567891011&lt;script type="text/javascript"&gt; jQuery.noConflict(); //将变量$的控制权移交给prototype.js (function($)&#123; //定义匿名函数 $(function()&#123; //匿名函数内部的$均为jQuery $("p").click(function()&#123; alert.($(this).text()); &#125;); &#125;); &#125;)(jQuery); //执行匿名函数且传递实参jQuery $('pp').style.display = 'none'; //使用prototype.js隐藏元素&lt;/script&gt; 2、jQuery在其他库之前导入 直接使用jQuery而非$来做jQuery的工作，$()方法作为其他库的快捷方式，无需调用jQuery.noConflict()方法 jQuery选择器jQuery选择器的优势1、简洁的写法使用$(&quot;#ID&quot;)代替document.getElementById()，使用$(&quot;tagName&quot;)代替document.getElementsByTagName()函数2、支持CSS1到CSS3选择器3、完善的处理机制，即，使用jQuery获取不存在的元素也不会报错 注：$(&quot;#tt&quot;)获取的永远是对象，即使网页上没有元素，因此当要使用jQuery检查某个元素在网页上是否存在，不能使用如下代码：12345if($("#tt"))&#123; /* do something */ &#125;应根据获取的元素长度来判断：if($("#tt").length &gt; 0)&#123; /* do something */ &#125;或转换成DOM对象：if($("#tt")[0])&#123; /* do something */ &#125; 基本选择器 选择器 描述 返回 示例 #id 根据给定id匹配一个元素 单个元素 $(“#test”)选取id为test的元素 .class 根据给定类名匹配元素 集合元素 $(“.test”)选取所有class为test的元素 element 根据给定元素名匹配元素 集合元素 $(“p”) * 匹配所有元素 集合元素 $(“*”) selector1,selector2… 将每个选择器匹配到的元素合并后一起返回 集合元素 $(“div,span,p.myClass”) 层次选择器 选择器 描述 返回 示例 $(“ancestor descendant”) 选取ancestor元素里所有descendant（后代）元素 集合元素 $(“div span”)选取div里所有span元素 $(“parent&gt;child”) 与CSS的子选择器一样 集合元素 $(“div&gt;span”) $(“prev+next”) 与CSS的相邻同胞选择器一样 集合元素 $(“.one+div”) $(“prev~sibling”) 与CSS的通用的同胞组合选择器一样 集合元素 $(“#two~div”) 可以使用next()方法代替$(&#39;prev+next&#39;)1$(".one+div"); ==&gt; $(".one").next("div"); 使用nextAll()代替$(&#39;#prev~sibling&quot;)1$("#prev~div"); ==&gt; $("#prev").nextAll("div"); 基本过滤选择器 选择器 描述 返回 示例 :first 选取第一个元素 单个元素 $(“div:first”)选取所有元素中第1个元素 :last 选取最后一个元素 单个元素 $(“div:last”)解释类似:first :not(selector) 去除所有与给定选择器匹配的元素 集合元素 $(“input:not(.myClass)”) :even 选取索引是偶数的元素，索引从0开始 集合元素 $(“input:even”) :odd 选取索引是奇数的元素，索引从0开始 集合元素 $(“input:odd”) :eq(index) 选取索引是index的元素，index从0开始 单个元素 $(“input:eq(1)”) :gt(index) 选取索引大于index的元素，index从0开始 集合元素 $(“input:gt(1)”) :lt(index) r选取索引小于index的元素，index从0开始 集合元素 $(“input:lt(1)”) :header 选取所有标题元素，例h1，h2 集合元素 $(“:header”) :animated 选取正在执行动画的元素 集合元素 $(“div:animated”) :focus 选取获得焦点的元素 集合元素 $(“:focus”) 内容过滤选择器 选择器 描述 返回 示例 :contains(text) 选取含有文本内容为“text”的元素 集合元素 $(“div:contains(‘me’)”)选取所有含有文本”me”的div元素 :empty 选取不包含子元素或文本的空元素 集合元素 $(“div:empty”) :has(selector) 选取含有选择器所匹配的元素的元素 集合元素 $(“div:has(p)”)选取含有p元素的div元素 :parent 选取含有子元素或文本元素的元素 集合元素 $(“div:parent”) 可见性过滤选择器 选择器 描述 返回 示例 :hidden 选取所有不可见元素 集合元素 $(“:hidden”)选取所有不可见元素 :visible 选取所有可见元素 集合元素 $(“div:visible”)选取可见的div元素 属性过滤选择器 选择器 描述 返回 示例 [attribute] 选择拥有此属性的元素 集合元素 $(“div[id]”)选取拥有id属性的div元素 [attribute=value] 选择拥有属性值为value的元素 集合元素 $(“div[title=test]”) [attribute!=value] 选择属性值不等于value的元素 集合元素 $(“div[title!=test]”),没有属性title的元素也会被选取 [attribute^=value] 选择属性值以value开始的元素 集合元素 $(“div[title^=test]”) [attribute$=value] 选择属性值以value结束的元素 集合元素 $(“div[title$=test]”) [attribute*=value] 选择属性值含有value的元素 集合元素 $(“div[title*=test]”) [attribute丨=value] 选择属性等于给定字符串或以该字符串为前缀（该字符串后跟一个连字符‘-’）的元素 集合元素 $(“div[title丨=”en”]”)选取title属性等于en或以en为前缀的元素 [attribute~=value] 选取属性用空格分隔的值中包含一个给定值的元素 集合元素 $(“div[title~=”uk”]”) [attribute1][attribute2] … 用属性选择器合并成复合选择器，满足多个条件，缩小范围 集合元素 $(“div[id][title$=”test”]”)选取拥有属性id并且属性title以”test”结束的div元素 子元素过滤选择器 选择器 描述 返回 示例 :nth-child(index/even/odd/equatioin) 选取每个父元素下第index个子元素或奇偶元素，index从1开始 集合元素 将为每一个父元素匹配子元素 :first-child 选取每个父元素的第一个子元素 集合元素 将为每一个父元素匹配子元素 :last-child 选取每个父元素的最后一个子元素 集合元素 将为每一个父元素匹配子元素 :only-child 若某个元素是其父元素唯一的子元素，则被匹配 集合元素 $(“ul li:only-child”)在&lt;ul&gt;中选取是唯一子元素的&lt;li&gt;元素 :nth-child()选择器功能如下：1、:nth-child(even)选择索引是偶数的元素2、:nth-child(2)选择索引是2的元素3、:nth-child(3n+1)选择索引是（3n+1）的元素，n从1开始 表单过滤选择器 选择器 描述 返回 示例 :enabled 选取所有可用元素 集合元素 $(“#form1 :enabled”) :disabled 选取所有不可用元素 集合元素 $(“#form1 :disabled”) :checked 选取所有被选中元素，单选，复选 集合元素 $(“input:checked”) :selected 选取所有被选中选项元素，下来列表 集合元素 $(“select option:selected”) 表单选择器 选择器 描述 返回 示例 :input 选取所有&lt;input&gt;&lt;textarea&gt;&lt;select&gt;&lt;button&gt; 集合元素 $(“:input”) :text 选取所有单行文本框 集合元素 $(“:text”) :password 选取所有密码框 集合元素 $(“:password”) :radio 选取所有单选框 集合元素 $(“:radio”) :checkbox 选取所有复选框 集合元素 $(“:checkbox”) :submit 选取所有提交按钮 集合元素 $(“:submit”) :image 选取所有图像按钮 集合元素 $(“:image”) :reset 选取重置按钮 集合元素 $(“:reset”) :button 选取所有按钮 集合元素 $(“:button”) :file 选取所有上传域 集合元素 $(“:file”) :hidden 选取所有不可见元素 集合元素 $(“:hidden”) 选择器中的注意事项1、选择器中含有&quot;.&quot;，&quot;#&quot;，&quot;(&quot;，&quot;]&quot;等特殊符号，需要转义，例：$(&quot;#id\\#b&quot;)2、属性选择器中的@符号需要去掉 jQuery中的DOM操作HTML-DOM操作查找节点（1）查找元素节点，使用选择器。 获取元素节点并打印出它的文本内容：如下 123var $li = $("ul li:eq(1)"); //获取&lt;ul&gt;里第2个&lt;li&gt;节点 var li_txt = $li.text(); //获取第2个&lt;li&gt;元素节点的文本内容console.log(li_txt); //打印文本内容 （2）查找属性节点，再找到元素之后，可以使用attr()方法获取元素属性 获取属性节点并打印出它的文本内容：如下 123var $para = $("p"); //获取&lt;p&gt;节点var p_txt = $para.attr("title"); //获取&lt;p&gt;元素节点属性titleconsole.log(p_txt); 创建节点（1）创建元素节点使用工厂函数$()来完成，$(html)，根据传入的HTML标记字符串，创建一个DOM对象，并转成jQuery对象返回12345678910111213141516171819202122232425262728293031例：$("&lt;li&gt;&lt;/li&gt;")``` （2）创建文本节点，与（1）类似，将文本内容一起包含在`HTML`标记字符串中 （3）创建属性节点，与（1）类似，将节点属性一起包含在`HTML`标记字符串中 ### 插入节点方法 | 描述 | 示例---|--- |---append()| 向每个匹配的元素内部追加内容 |&lt;p&gt;我想说：&lt;/p&gt; $("p").append("&lt;b&gt;你好&lt;/b&gt;"); &lt;p&gt;我想说：&lt;b&gt;你好&lt;/b&gt;&lt;/p&gt;appendTo()|将所有匹配元素追加到指定元素中 ，与append方法颠倒$(A).append的操作，既不是将B追加到A中，而是将A追加到B中 |&lt;p&gt;我想说：&lt;/p&gt; $("&lt;b&gt;你好&lt;/b&gt;").appendTo("p"); &lt;p&gt;我想说：&lt;b&gt;你好&lt;/b&gt;&lt;/p&gt;prepend()|向每个元素内部前置内容 | &lt;p&gt;我想说：&lt;/p&gt;$("p").prepend("&lt;b&gt;你好&lt;/b&gt;");&lt;p&gt;&lt;b&gt;你好&lt;/b&gt;我想说：&lt;/p&gt;prependTo()| 将所有匹配元素前置到指定元素中，与prependTo方法颠倒 | &lt;p&gt;我想说：&lt;/p&gt;$("p").prependTo("&lt;b&gt;你好&lt;/b&gt;");&lt;p&gt;&lt;b&gt;你好&lt;/b&gt;我想说：&lt;/p&gt;after() | 在每个匹配元素之后插入内容 | &lt;p&gt;我想说：&lt;/p&gt;$("p").after("&lt;b&gt;你好&lt;/b&gt;");&lt;p&gt;我想说：&lt;/p&gt;&lt;b&gt;你好&lt;/b&gt;insertAfter() | 将所有匹配元素插入到指定元素之后 | &lt;p&gt;我想说：&lt;/p&gt;$("&lt;b&gt;你好&lt;/b&gt; ").insertAfter("p");&lt;p&gt;我想说：&lt;/p&gt;&lt;b&gt;你好&lt;/b&gt;before() | 在每个匹配的元素之前插入内容 | &lt;p&gt;我想说：&lt;/p&gt;$("p").before("&lt;b&gt;你好&lt;/b&gt;");&lt;b&gt;你好&lt;/b&gt; &lt;p&gt;我想说：&lt;/p&gt;insertBefore() | 将所有匹配元素插入到指定元素之前 | &lt;p&gt;我想说：&lt;/p&gt;$("&lt;b&gt;你好&lt;/b&gt; ").insertBefore("p");&lt;b&gt;你好&lt;/b&gt; &lt;p&gt;我想说：&lt;/p&gt;这些节点的方法不仅能将新创建的DOM元素插入到文档中，也能对原来的DOM元素进行移动。 ### 删除节点 （1）remove方法 作用从 `DOM` 中删除所有匹配的元素，传入的参数用于根据 `jQuery` 表达式来删选元素 ```javascript$("ul li:eq(1)").remove(); // 获取第二个 &lt;li&gt; 元素节点后，将它从网页中删除$li.appendTo("ul"); // 把刚才删除的元素添加到 &lt;ul&gt; 元素中 这个方法的返回值是一个指向已被删除的节点的引用，因此可以将其保存在一个变量中，以后还可以使用。 （2）datach方法 detach() 和 remove() 一样，也是从 DOM 中去掉所有匹配的元素，但是两者的区别是，这个方法不会把匹配的元素从 jQuery 对象中删除，去掉的元素的所有绑定的事件、附加的数据等都会保留下来。 （3）empty方法 并不能算是删除节点，而是清空节点，清空指定元素的所有后代节点。 复制节点使用clone方法，使用参数true可以同时复制元素所绑定事件 123456789101112131415161718192021$("ul li").click(function()&#123; $(this).clone().appendTo("ul");&#125;)``` 复制的节点后，被复制的新元素并不具有任何行为，如果需要新元素也具有相同的行为，那么就需要在 `clone()` 方法中传入参数 `true` ```javascript$("ul li").click(function()&#123; $(this).clone(true).appendTo("ul");&#125;)``` ### 替换节点 `replaceWith();`-&gt;将所有匹配的元素都替换成 `HTML` 或者 `DOM` 元素，绑定的事件将会消失 `replaceAll();`-&gt;和 `replaceWith()` 相反 ```javascript$("p").replaceWith("&lt;strong&gt;hello world&lt;/strong&gt;");$("&lt;strong&gt;hello world&lt;/strong&gt;").replaceAll("p"); 以上两句是一样的效果。注意：替换前元素有绑定事件，替换后会被清除，需要重新再新元素上重新绑定事件。 包裹节点使用wrap()方法; -&gt;将所有的元素单独包裹。 123&lt;strong&gt;hello world&lt;/strong&gt;$("strong").wrap("&lt;b&gt;&lt;/b&gt;"); //用b标签把strong元素包裹起来&lt;b&gt;&lt;strong&gt;hello world&lt;/strong&gt;&lt;/b&gt; wrapAll()和wrapInner()；（1）wrapAll。将所有匹配元素用一个元素来包裹，与wrap不同，wrap是将所有匹配元素单独包裹： 12345&lt;strong&gt;hello world&lt;/strong&gt;&lt;strong&gt;hello world&lt;/strong&gt;$("strong").wrap("&lt;b&gt;&lt;/b&gt;");&lt;b&gt;&lt;strong&gt;hello world&lt;/strong&gt;&lt;/b&gt;&lt;b&gt;&lt;strong&gt;hello world&lt;/strong&gt;&lt;/b&gt; 而使用wrapAll之后： 123456789101112131415&lt;b&gt;&lt;strong&gt;hello world&lt;/strong&gt;&lt;strong&gt;hello world&lt;/strong&gt;&lt;/b&gt;``` 注意：若被包裹元素之间有其他元素，则其他元素会被放到包裹元素之后 （2）wrapInner方法 该方法将每一个匹配的元素的子内容用其他结构化标记包裹起来： ```javascript&lt;strong&gt;hello world&lt;/strong&gt;$("strong").wrapInner("&lt;b&gt;&lt;/b&gt;");&lt;strong&gt;&lt;b&gt;hello world&lt;/b&gt;&lt;/strong&gt; 属性操作（1）获取和设置属性 使用attr()方法 获取属性12var $p = $("p"); //获取&lt;p&gt;节点var p_txt = $p.attr("title");//获取&lt;p&gt;元素节点属性title 设置属性 12345678910$("p").attr("title","value"); //用于设置单个属性$("p").attr(&#123;"title":"you title","name":"you name"&#125;); //用于设置多个属性，使用对象传递``` 注：类似这样的属性还有`html()`、`css()`、`text()`、`height()`、`widht()`、`val()`等方法。 （2）删除属性 使用`removeAttr()`方法 ```javascript$("p").removeAttr("title");//删除&lt;p&gt;元素的属性title 样式操作（1）获取样式和设置样式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用attr()方法（2）追加样式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用addClass()方法 12345678910111213141516171819202122232425$("p").addClass("another");//给&lt;p&gt;元素追加"another"类。``` **注：** &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(1)如果给一个元素添加了多个`class`值，那么就相当于合并了它们的样式。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(2)如果有不同的`class`设定了同一样式属性，则后者覆盖前者。 （3）移除样式 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用`removeClass()`,参数为要移除的`class`名，不带参数则把所有`class`移除 （4）切换样式 `toggle()`方法。 ```javascript$toggleBtn.toggle(function()&#123; // 显示元素 代码1&#125;,function()&#123; //隐藏元素 代码2&#125;);```` `toggle`的作用是，交替执行代码1和代码2，主要是用于控制行为上的重复切换 `toggleClass()`方法 用于控制样式上的切换，类名存在则删除，不存在则添加```javascript$("p").toggleClass("another"); （5）判断是否含有某个样式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasClass()方法用于判断是否含有某个class，有返回true，没有返回false 设置和获取HTML、文本和值（1）类似于JavaScript的innerHTML属性，可以用于获取和设置元素（传递参数）的HTML内容。注:可用于XHTML，不可用于XML。（2）text()方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似于JavaScript的innerText属性，用于获取和设置元素（传递参数）的文本内容。（3）val()方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似于JavaScript的value属性，用于设置和获取元素的值，无论元素是文本框，下来列表还是单选框，都可以返回元素值，若为多选，返回一个包含所有选择的值的数组。 遍历节点（1）children()方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取得匹配元素的子元素集合，只考虑子元素，不考虑后代元素。1$("p").children(); （2）next()方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于取得匹配元素后面紧邻的同辈元素。（3）prev()方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于取得匹配元素前面紧邻的同辈元素。1$("p").prev();//取得紧邻&lt;p&gt;元素前的同辈元素 （4）siblings()方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于取得匹配元素前后所有同辈元素。1$("p").siblings();//取得&lt;p&gt;元素的同辈元素 （5）closest()方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该方法用于取得最近的匹配元素。首先检查元素本身，接着逐级向上往祖先元素查找，没找到则返回空jQuery对象 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如，给点击的目标元素的最近的li元素添加颜色。如下： 123$(document).bind("click",function(e)&#123;$(e.target).closest("li").css("color","red");&#125;) （6）parent()，parents()，closest()区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent()，获取集合中每个匹配元素的父元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parents()，获取集合中每个匹配元素的祖先元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closese()，从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素 CSS-DOM操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以直接利用css()方法获取元素的样式属性：$(&quot;p&quot;).css(&quot;color&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论是外部CSS导入，还是直接拼接在HTML元素中，都可以通过css()方法获得&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置样式与attr()方法类似 12$("p").css("color","red"); //设置单个$("p").css(&#123;"color":"red","fontSize":"30px"); //设置多个 注：如果值是数字，则自动转化为像素值获取元素高度，可以直接使用height属性1$("p").height(); 注：1、jQuery1.2之后height可用于获取window和document的高度2、css方法获取的高度值与样式设置有关，而height获取的是元素在页面实际高度，与样式置无关，且不带单位与height对应的还有width()方法。 其他几个经常使用的方法： （1）offset()方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于获取元素在当前视窗的相对偏移，返回对象包含两个属性，top，left，只对可见元素有效。（2）position()方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于获取元素相对于最近一个position样式属性设置为elative或absolute的祖先节点的相对偏移，返回对象也包含连个属性top，left。（3）scrollTop()方法和scrollLeft()方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分别用于获取元素的滚动条距顶端和距左侧的距离，还可以接受一个参数，指定滚动条滚动到指定位置。 jQuery中的事件和动画jQuery中的事件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript中通常使用window.onload方法，jQuery中使用$(document).ready()方法。 1、执行时机&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.onload方法在网页所有元素都加载完毕之后才执行，$(document).ready()方法在DOM完全就绪就可以被调用 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于$(document).ready()方法内注册事件，只要DOM就绪就会被执行，因此有可能此时元素的关联文件还未下载完，例如图片的宽高可能无效。为解决此问题，使用jQuery另一个方法—–load()方法。load()方法会在元素的onload事件绑定一个处理函数。 123$(window).load(function()&#123; //编写代码&#125;); 等价于javascript中的以下代码： 123window.onload = function()&#123; //编写代码&#125;; 多次使用windows.onload()方法不能保存多个函数引用，而$(document).ready()可以 简写形式123$(document).ready(function()&#123; //编写代码&#125;); 简写123$(function()&#123; //编写代码&#125;); $(document)也可以简写为$()，当$()不带参数时，默认参数就是document，因此还可以简写： 123$().ready(function()&#123; // coding&#125;); 事件绑定使用bind()方法来对匹配元素进行特定事件绑定，调用格式：1bind(type [,datd] ,fn); 1.第一个参数是事件类型，类型包括：blur focus load resize scroll unload cliock dblclick mousedownmouseup mouseover mouseout mouseenter mouseleave change select submit keyup keydown keypress keyuperror2.第二个参数是可选参数，作为event.data属性值传递给事件对象的额外数据对象3.第三个参数则是用来绑定的处理函数使用：123$("#panel h5.head").bind("click",function()&#123; // coding&#125;); 合成事件jQuery有两个合成事件—hover()、toggle()，类似ready()，hover()和toggle()都是jQuery自定义方法1、hover()方法1hover(enter,leave) hover(fn1,fn2,...fnN)方法用于模拟光标悬停事件，当光标移动到元素上时，会触发第一个函数（enter），当光标移出这个元素时会触发第二个函数（leave）2、toggle()方法 —在jQuery1.9被移除toggle() 方法用于模拟鼠标的连续点击事件，第一次单击元素，触发第一个函数，第二次单击同一个元素，会触发第二个函数，如果有更多的函数，则依次触发，直到最后一个。 事件冒泡停止事件冒泡使用event.stopPropagation()可以停止事件冒泡 假设网页上有两个元素，其中一个嵌套在另一个元素里面，并且都被绑定了 click事件。同时 &lt;body&gt;元素上也绑定了click 事件，这样的话，点击最内层的元素，会触发三次 click事件。这是因为 JavaScript的事件冒泡机制。在 jQuery中，提供了 stopPropagation() 方法来停止冒泡。 阻止默认行为网页中的元素有自己的默认行为，例如点击超链接会跳转、单击提交按钮，表单会提交，有时需阻止事件默认行为jQuery中提供了preventDefault()方法来阻止默认行为event.preventDefault() 注：若想对事件对象停止冒泡和默认行为，可以在事件处理函数中返回false，这是对在事件对象上同时调用stopPropagation和preventDefault的一种简写方式 事件对象的属性 方法名称 描述 event.type 获取到事件的类型 event.preventDefault() 阻止默认的事件行为 stopPropagation() 阻止事件冒泡 event.tagent() 获取到触发事件的元素 event.relatedTarget() mousover 和 mouseout 所发生的元素 event.pageX event.pageY 获取到光标相对于页面的 x 坐标和 y 坐标 event.which() 鼠标单击事件中获取到的左、中、右键，在键盘事件中获取键盘的按键 event.metaKey() 为键盘事件获取ctrl键 移除事件1、移除按钮元素上以前注册的事件使用unbind()方法，语法结构：1unbind([type],[data]); 第一个参数是事件类型，第二个参数是要移除的函数&nbsp;&nbsp;&nbsp;&nbsp;（1）若没有参数，删除所有绑定事件&nbsp;&nbsp;&nbsp;&nbsp;（2）若提供了事件类型作为参数，则只删除该类型的绑定事件&nbsp;&nbsp;&nbsp;&nbsp;（3）若都传递，则只有这个特定的事件处理函数会被删除 one() 方法对于只要触发一次，随后要立即解除绑定的情况，jQuery提供了 one() 方法。当处理函数触发一次后，立即被删除。 模拟操作1、常用模拟使用trigger()方法完成模拟操作：123456789101112$("#btn").trigger("click"); // 触发id为btn的click事件// 也可以简化：$("#btn").click();``` 2、触发自定义事件 `trigger()`方法不仅可触发浏览器支持的具有相同名称的事件，也可以触发自定义名称的事件 例： ```javascript$('#btn').bind("myClick",function()&#123; $('#test').append("&lt;p&gt;我的自定义事件&lt;/p&gt;");&#125;);$('#btn').trigger("myClick"); 3、传递数据 1234$('#btn').bind("myClick",function(event,message1,message2)&#123; $('#test').append("&lt;p&gt;"+message1+message2+"&lt;/p&gt;");&#125;);$('#btn').trigger("myClick",["我的自定义","事件"]); 4、执行默认操作 trigger()方法触发事件后，还会执行浏览器默认操作 1$('input').trigger("focus"); 不仅会触发绑定在input上的事件，也会使input元素获得焦点使用triggerHandler()方法可以只触发事件，而不执行浏览器默认操作 1$('input').triggerHandler("focus"); 只会触发绑定事件，不会是input元素获得焦点 其他用法1、绑定多个事件类型12345$(function()&#123; $("div").bind("mouseout mouseover",function()&#123; //do something &#125;);&#125;; 2、添加事件命名空间，便于管理1234567891011121314151617181920212223242526272829$(function()&#123; $('div').bind("click.plugin",function()&#123; $('body').append("&lt;p&gt;click事件&lt;/p&gt;"); &#125;); $('div').bind("mouseover.plugin",function()&#123; $('body').append("&lt;p&gt;mouseover事件&lt;/p&gt;"); &#125;); $('div').bind("dbclick",function()&#123; $('body').append("&lt;p&gt;dbclick事件&lt;/p&gt;"); &#125;); $('button').click(function()&#123; $('div').unbind(".plugin"); &#125;);&#125;);``` 在所绑定的事件后面添加命名空间，删除时只需要指定命名空间即可，单击`&lt;button&gt;`后，plugin的命名空间被删除，而不再`plugin`空间中的`dbclick`事件依然存在 3、相同事件名称，不同命名空间执行方法 ```javascript$(function()&#123; $('div').bind("click",function()&#123; $('body').append("&lt;p&gt;click事件&lt;/p&gt;"); &#125;); $('div').bind("click.plugin",function()&#123; $('body').append("&lt;p&gt;click.plugin事件&lt;/p&gt;"); &#125;); $('button').click(function()&#123; $('div').trigger("click!"); //注意感叹号 &#125;);&#125;); 单击&lt;div&gt;元素后，会同时触发click事件和click.plugin事件，若只单击则只触发click事件，不触发click.plugin事件，注意trigger(&quot;click!&quot;)后面的感叹号的作用是匹配所有不包含命名空间中的click方法若两者都要触发，改为如下代码：1$("div").trigger("click"); jQuery中的动画 方法名 说明 hide() show() 同时修改多个样式属性，即高度、宽度和不透明度 fadeIn() fadeOut() 只改变不透明度 slideUp() slideDown() 只改变高度 toggle() 用来代替 hide() 和 show() 方法 slideToggle() 用来代替 slideUp() 和 slideDown() fadeToggle() 用来代替 fadeIn() 和 fadeOut() animate() 属于自定义动画的方法 1、show()方法和hide()方法 （1）show()方法和hide()方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用hide()方法会将该元素的display样式改为“none”元素隐藏后可以使用show()方法将元素的display样式设置为先前的显示状态（2）show()方法和hide()方法让元素动起来&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;希望调用show()方法时元素慢慢地显示出来，可以为show()方法指定一个速度参数，例如，速度关键字“slow” 12345678910111213$(“element”).show("slow");``` 元素会在`600ms`内慢慢显示，还有`normal（400ms）`，`fast（200ms）`，还可以指定一个数字（单位是毫秒） ```javascript$(function()&#123; $("#panel h5.head").toggle(function()&#123; $(this).next().show("slow"); &#125;,function()&#123; $(this).next().hide(1000); &#125;);&#125;); 2、fadeIn()方法和fadeOut()方法 fadeIn(),fadeOut()只改变元素的不透明度，fadeOut()会在指定的时间内降低元素的不透明度，直至元素完全消失（display:none），fadeIn()相反。1234567$(function()&#123; $("#panel h5.head").toggle(function()&#123; $(this).next().fadeOut(); &#125;,function()&#123; $(this).next().fadeIn(); &#125;);&#125;); 也可以使用关键字和指定时间参数，单位毫秒 3、slideUp()方法和slideDown()方法 这两个方法只会改变元素的高度，若一个元素的display为none，slideDown()会将这个元素自上而下延伸显示，slideUp()正好相反 123456789101112131415161718192021222324252627282930313233343536$(function()&#123; $("#panel h5.head").toggle(function()&#123; $(this).next().slideDown(); &#125;,function()&#123; $(this).next().slideUp(); &#125;);&#125;);``` 一样可以使用关键字和指定时间参数，单位毫秒 ### 自定义动画方法animate()```javascript animate(params, speed, callback);``` （1）`params`：一个包含样式属性及值的映射，例：`&#123;property:"value",property:"value1",....&#125; ` （2）`speed`：速度参数，可选 （3）`callback`：动画完成时执行的函数，可选 1、自定义简单动画 ```javascript#panels&#123; position: relative; width: 100px; height: 100px; border: 1px solid #0050d0; background: #96e555; cursor: pointer;&#125;&lt;div id="panels"&gt;&lt;/div&gt;$(function()&#123; $("#panels").click(function()&#123; $(this).animate(&#123;left:"500px"&#125;,3000); &#125;);&#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三秒之内，div右移500px，只会移动一次 2、累加、累减动画 12345$(function()&#123; $("#panels").click(function()&#123; $(this).animate(&#123;left:"+=500px"&#125;,3000); &#125;);&#125;); 3、多重动画（1）同时执行多个动画12345$(function()&#123; $("#panels").click(function()&#123; $(this).animate(&#123;left:"500px",width:"200px",height:"200px"&#125;,3000); &#125;);&#125;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是同时执行的动画 （2）按顺序执行多个动画 把多个动画拆开即可 1234567 $(function()&#123; $("#panels").click(function()&#123; $(this).animate(&#123;left:"500px"&#125;,3000); $(this).animate(&#123;width:"200px"&#125;,3000); $(this).animate(&#123;height:"200px"&#125;,3000); &#125;);&#125;); 链式写法：1234567$(function()&#123; $("#panels").click(function()&#123; $(this).animate(&#123;left:"500px"&#125;,3000) .animate(&#123;width:"200px"&#125;,3000) .animate(&#123;height:"200px"&#125;,3000); &#125;);&#125;); 4、综合动画12345678$(function()&#123; $("#panels").css("opacity","0.5");//设置不透明度 $("#panels").click(function()&#123; $(this).animate(&#123;left:"400px",height:"200px",opacity:"1"&#125;,3000) .animate(&#123;top:"200px",width:"200px"&#125;,3000) .fadeOut("slow"); &#125;);&#125;); 5、动画回调函数若想在最后完成时改变CSS样式，而不是淡出，则需要使用回调函数，而不是将css()方法写在fadeOut()方法的位置，因为css()方法并不会加入动画队列 123456789$(function()&#123; $("#panels").css("opacity","0.5");//设置不透明度 $("#panels").click(function()&#123; $(this).animate(&#123;left:"400px",height:"200px",opacity:"1"&#125;,3000) .animate(&#123;top:"200px",width:"200px"&#125;,3000,function()&#123; $(this).css("border","5px solid blue"); &#125;); &#125;);&#125;); 注：callback回调函数适合jQuery的所有动画效果 停止动画和判断是否处于动画状态1、停止元素的动画使用stop()方法1stop([clearQueue],[gotoEnd]); 参数均为可选参数，为boolean值clearQueue表示是否清空动画队列，gotoEnd表示直接将正在执行的动画跳转到末状态如果直接使用stop()方法，则会立即停止正在执行的动画，若还有动画等待执行，则以当前状态继续执行下一个动画 2、判断元素是否处在动画状态12345678910111213141516171819202122232425262728if(!$("element").is(":animate"))&#123; //do something&#125;``` 3、延迟动画 使用`delay()`方法可以对动画进行延迟操作 ```javascript$(function()&#123; $("#panels").css("opacity","0.5");//设置不透明度 $("#panels").click(function()&#123; $(this).animate(&#123;left:"400px",height:"200px",opacity:"1"&#125;,3000) .delay(1000) // 延迟的是下一个动画 .animate(&#123;top:"200px",width:"200px"&#125;,3000); &#125;);&#125;);``` 其他动画方法 1、`toggle(speed,[callback])`方法 2、`slideToggle(speed,[easing],[callback])`; 3、`fadeTo(speed,opacity,[callback])`; 4、`fadeToggle(speed,[easing],[callback])`; *1、`toggle()` *可切换元素的可见状态 ```javascript $("#panel h5.head").click(function()&#123; $(this).next().toggle();&#125;); 等价于：1234567$(function()&#123; $("#panel h5.head").toggle(function()&#123; $(this).next().show("slow"); &#125;,function()&#123; $(this).next().hide(1000); &#125;);&#125;); 2、slideToggle()方法通过高度变化切换匹配元素可见性3、fadeTo()方法把元素的不透明度以渐进方式调整到指定值，只调整元素的不透明度，4、fadeToggle()方法通过元素不透明度变化来切换元素的可见性，只调整元素的不透明度 jQuery与Ajax的应用Ajax的优势和不足Ajax的优势1、不需要插件支持2、优秀的用户体验3、提高Web程序的性能4、减轻服务器和带宽的负担 Ajax的不足1、浏览器对XMLHttpRequest对象的支持度不足2、破坏浏览器前进、后退按钮的正常功能3、对搜索引擎的支持的不足4、开发和调试工具的缺乏 Ajax的XMLHttpRequest对象Ajax的核心是XMLHttpRequest对象，它是Ajax实现的关键—-发送异步请求、接收响应及执行回调都是通过它来完成的。IE5、IE6是以ActiveXObject的方式引入XMLHttpRequest对象的，而其他浏览器的XMLHttpRequest对象是window的子对象 使用原生 JS 写一个 Ajax 一. 定义一个函数，通过该函数来获取异步信息123function Ajax()&#123; //定义一个函数，通过该函数来获取异步信息&#125; 声明一个空对象来装入 XMLHttpRequest 对象 var xmlHttpReq = null; // 声明一个空对象来装入 XMLHttpRequest 对象 二. 实例化一个 XMLHttpRequest 对象1234if(window.XMLHttpRequest)&#123; xmlHttpReq = new XMLHttpRequest(); // 实例化一个 XMLHttpRequest 对象&#125; 使用 open() 方法初始化 XMLHttpRequest 对象，指定 HTTP 方法和要使用的服务器 URL; 12xmlHttpReq.open("GET","test.php",true); // 调用 open() 方法并采用异步方式 使用 onreadystatechange 属性来注册该回调事件处理器，当 readystatus 状态改变时，会激发 onreadystatechange事件然后调用回调函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169 xmlHttpReq.onreadystatechange = RequestCallBack; ``` 使用 `send()` 方法发送请求，使用 `GET`方式可以不指定参数或者使用 `null `参数`xmlHttpReq.send(null)`; 当请求状态改变时，`XMLHttpRequest` 对象调用 `onreadystatechange` 属性注册的事件处理器，在处理响应之前，事件处理器应该首先检查 `readyStatus `的值和` HTTP `状态。当请求完成加载`（readyStatus == 4）`并且响应已经成功`（HTTP 状态值为 200）`，就可以处理响应内容； ```javascriptfunction RequestCallBack() &#123; if(xmlHttpReq.readyState == 4)&#123; if(xmlHttpReq.status == 200)&#123; document.getElementById("resText").innerHTML = xmlHttpReq.responseText; &#125; &#125;&#125; ``` ## jQuery中的Ajax `jQuery` 对 `Ajax` 操作进行封装，在 `jQuery `中，`$.ajax() `是最底层的方法，第二层是 `load()`、`$.get()`、`$.post()`、`$.grtJSON()`。 **1、load()方法** 语法结构：`load(url [,data] [,callback]) `**load()方法参数解释** 参数 | 类型---|---url | Stringdata（可选） | Objectcallback（可选） | Function筛选载入的`HTML`文档```javascript$('#resText').load("test.html .para"); // 载入test.html页面中class为“para”的内容``` **传递方式** `load()`方法会根据参数`data`来自动指定，有参数传递为`POST`方式，无参数则为`GET`方式 **回调函数** 有3个参数：1、请求返回的内容；2、请求的状态；3、`XMLHttpRequest`对象 **注**：通常用于从`Web`服务器获取静态文件 **2、$.get()与$.post()方法** （1）`$.get()`使用`GET`方式来进行异步请求 语法结构：`$.get(url [,data] [,callback] [,type]); `**$.get()方法参数解释** 参数 | 类型---|---url | Stringdata（可选） | Objectcallback（可选）） | Functiontype（可选） | String**回调函数** 只有两个参数：1、`data`，返回的内容，`xml`文档，`json`文件等；2、请求状态：`success`、`error`、`notmodified`、`timeout` **注**：只有当数据成功返回`(success)`才被调用 （2）`$.post()`使用`POST`方式进行异步请求 ` $.post( url [, data] [, callback] [, type]) ` **GET与POST的区别** &lt;1&gt;`GET`请求会将参数跟在`URL`后进行传递，`POST`则是作为`HTTP`实体内容发送个`Web`服务器。 &lt;2&gt;`GET`对传输数据有大小限制（通常不大于`2kb`），而`POST`则要比`GET`多的多（理论上不限制） &lt;3&gt;`GET`请求会被浏览器缓存下来，在某种情况下会有严重的安全性问题，而`POST`则可避免 &lt;4&gt;`GET`与`POST`传递的数据在服务器端获取方式也不相同 **3、$.getScript()方法和$.getJson()方法** `（1）$.getScript()` 使用`$.getScript()`方法加载一个`js`文件就跟加载一个`HTML`页面一样简单，而且不需要对`js`文件进行处理，`js`文件会自动执行 **回调函数** 会在`js`加载成功后执行 （2）`$.getJson()` `$.getJson()`用于加载`json`文件 `$.each()`方法，`jQuery`中用于遍历对象和数组，接受两个参数：1、数组或对象；2、回调函数（接受两个参数：1、对象成员或数组索引；2、对应变量或内容） **4、$.ajax()方法** `$.ajax()` 方法是 `jQuery` 最底层的 `Ajax` 实现， `$.ajax(option)` 参数名称 | 类型 | 说明---|--- |---url | String | 发送请求的 URL（默认为当前页面）type | String | 请求方式，默认为 GETtimeout | Number | 设置请求超时时间（毫秒）data | Object 或 String | 发送到服务器的数据dataTpye | String | 预期服务器返回的数据类型beforeSend | Function | 发送请求前可以修改 XMLHttpResponse 对象的函数complete | Function | 请求完成后调用的回调函数（请求失败或者成功均调用）success | Function | 请求成功后调用的回调函数error | Function | 请求失败后调用的回调函数global | Function | 默认为 true。是否触发全局 Ajax 事件## 序列化元素**1、serialize()方法** 作用于一个`jQuery`对象，能够将`DOM`元素内容序列化为字符串，用于`Ajax`请求 **注**：参数传递时要注意将参数进行编码，即使用`URI`编码，若不希望编码带来麻烦，可以使用`serialize()`方法，它会自动编码 **2、serializeArray()方法** 将`DOM`序列化后，返回`json`格式数据 **3、$.param()方法** `serialize()`方法核心，用以对一个对象按照`key/value`进行序列化 ## jQuery中的Ajax全局事件 当`Ajax`请求开始时，触发`ajaxStart()`方法的回调函数；当`Ajax`请求结束时，触发`ajaxStop()`方法的回调函数 其他的全局方法 方法名称 | 说明---|---ajaxComplete(callback) | Ajax请求完成时执行函数ajaxError(callback) | Ajax请求发生错误时执行函数，捕捉到的错误可以作为最后一个参数传递ajaxSend(callback) | Ajax请求发送前执行的函数ajaxSuccess(callback) | Ajax请求成功时执行函数## jQuery 性能优化1、使用最新版的`jQuery`类库 2、使用合适的选择器（1、尽量使用id选择器，2、尽量给选择器指定上下文） 3、缓存对象（即使用一个变量将需要重复使用的`jQuery`对象存下来，以避免多次获取） 4、循环时的`DOM`操作（减少`DOM`操作） 5、数组方式使用`jQuery`对象（尽量使用`for`或`while`循环来处理`jQuery`对象，而不是使用`$.each()`） **注**：检查`jQuery`对象是否存在的方式应该使用`length`属性 6、事件代理 7、将代码转化为`jQuery`插件 8、使用`join()`来拼接字符串，替代使用`“+”`来拼接 9、合理利用`HTML5`的`Data`属性 10、尽量使用原生的`JavaScript`方法 11、压缩`JavaScript` ### 使用合适的选择器 1. `$(“#id”)` `id` 选择器无疑是最佳提高性能的方式。因为 `jQuery `底层直接调用本地方法` document.getElementById()`，直接通过 `id `返回对应的元素可以有效的缩小你定位的` DOM `元素，建议从最近的 `ID `元素开始往下搜索。 2. `$(“p”)`、`$(“div”)`、`$(“input”) `标签选择器是性能优化第二选择，因为` jQuery` 也是直接调用` JS `原生方法 3. `$(“.class”)` 这是 `jQuery` 封装的函数，`ie9+` 以上是使用 `JS` 的原生方法，`ie9` 一下是使用 `DOM` 搜索方式来实现 4. `$(“[attribute=value]”)`：利用属性来定位` DOM` 元素，大部分都是使用` DOM `搜索方式来达到效果。所以性能并不是很理想 5. `$(“:hidden”)`：这和上面利用属性类似，并且` jQuery` 需要搜索每一个元素来定位这个选择器，所以尽量不要使用。 ### 缓存对象 我们可以将经常用的对象使用变量缓存起来，因为 `jQuery `会在创建每一个选择器的过程中，查找 `DOM`。 **不要让相同的选择器在你的代码中出现多次。** ### 循环时的 DOM 操作 在一些循环时，例如 `for()`、`while()`、`$.each()` 使用这些方法处理` DOM` 元素时，要尽可能的减少操作 `DOM`，可以使用变量将来储存元素，最后一次性将生产的` DOM `插入或者删除。 ### 数组方式使用 jQuery 对象使用 `jQuery` 选择器获得的结果是一个 `jQuery` 对象，然而，`jQuery`类库会让你感觉你正在使用一个定义了索引和长度的数组。在性能方面，建议使用 `for` 或者 `while` 循环来处理，而不是 `$.each()`### 事件代理 每一个 `JavaScript` 事件（例如：`click`、`mouseover` 等）都会冒泡到父节点，当我们需要给多个元素调用同个函数时会很有用。 比如，我们要单击表格的行使得改行背景颜色改变 ```javascript$("myTable td").click(function()&#123; $(this).css("background",'red')&#125;)``` 如果你是这样写的话，那么恭喜你，提供了一个错误的示例，🎉🎉。这样的弊端是，假使总共有` 100` 个` td`，那么在使用以上方式的时候，你绑定了` 100` 个事件，天辣，是不是很恐怖。 正确的姿势是，只需要向他们的父节点绑定一次事件，然后通过 `event.target` 获取到当前点击的元素。 ```javascript$("myTable").click(function()&#123; var $clicked = $(e.target); // 捕捉到触发的目标元素 $clicked.css("background",'red');&#125;) 也可以这样写 123$("myTable td").on('click','td', function()&#123; $(this).css("background",'red')&#125;)]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
</search>
